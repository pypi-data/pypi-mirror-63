# coding: utf-8

"""
    Flip API

    Flip  # noqa: E501

    The version of the OpenAPI document: 3.1
    Contact: cloudsupport@telestream.net
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from telestream_cloud_flip.api_client import ApiClient
from telestream_cloud_flip.exceptions import (
    ApiTypeError,
    ApiValueError
)


class FlipApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def cancel_encoding(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Cancels an Encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_encoding(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CanceledResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.cancel_encoding_with_http_info(encoding_id, factory_id, **kwargs)  # noqa: E501

    def cancel_encoding_with_http_info(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Cancels an Encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_encoding_with_http_info(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CanceledResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_encoding" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `cancel_encoding`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `cancel_encoding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}/cancel.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CanceledResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_video(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Cancel video and all encodings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_video(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CanceledResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.cancel_video_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def cancel_video_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Cancel video and all encodings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_video_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CanceledResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_video" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `cancel_video`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `cancel_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}/cancel.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CanceledResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_profile(self, profile_id, factory_id, copy_profile_body, **kwargs):  # noqa: E501
        """Copies a given Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_profile(profile_id, factory_id, copy_profile_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str profile_id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param CopyProfileBody copy_profile_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.copy_profile_with_http_info(profile_id, factory_id, copy_profile_body, **kwargs)  # noqa: E501

    def copy_profile_with_http_info(self, profile_id, factory_id, copy_profile_body, **kwargs):  # noqa: E501
        """Copies a given Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_profile_with_http_info(profile_id, factory_id, copy_profile_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str profile_id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param CopyProfileBody copy_profile_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Profile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['profile_id', 'factory_id', 'copy_profile_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_profile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'profile_id' is set
        if self.api_client.client_side_validation and ('profile_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['profile_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `profile_id` when calling `copy_profile`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `copy_profile`")  # noqa: E501
        # verify the required parameter 'copy_profile_body' is set
        if self.api_client.client_side_validation and ('copy_profile_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['copy_profile_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `copy_profile_body` when calling `copy_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in local_var_params:
            path_params['profile_id'] = local_var_params['profile_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'copy_profile_body' in local_var_params:
            body_params = local_var_params['copy_profile_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/{profile_id}/copy.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_encoding(self, factory_id, create_encoding_body, **kwargs):  # noqa: E501
        """Creates an Encoding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_encoding(factory_id, create_encoding_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param CreateEncodingBody create_encoding_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_encoding_with_http_info(factory_id, create_encoding_body, **kwargs)  # noqa: E501

    def create_encoding_with_http_info(self, factory_id, create_encoding_body, **kwargs):  # noqa: E501
        """Creates an Encoding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_encoding_with_http_info(factory_id, create_encoding_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param CreateEncodingBody create_encoding_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Encoding, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'create_encoding_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_encoding" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `create_encoding`")  # noqa: E501
        # verify the required parameter 'create_encoding_body' is set
        if self.api_client.client_side_validation and ('create_encoding_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_encoding_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_encoding_body` when calling `create_encoding`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_encoding_body' in local_var_params:
            body_params = local_var_params['create_encoding_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Encoding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_factory(self, **kwargs):  # noqa: E501
        """Creates a new factory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_factory(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Factory factory:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_factory_with_http_info(**kwargs)  # noqa: E501

    def create_factory_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a new factory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_factory_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Factory factory:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Factory, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_factory" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'factory' in local_var_params:
            body_params = local_var_params['factory']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/factories.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Factory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_profile(self, factory_id, **kwargs):  # noqa: E501
        """Creates a Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_profile(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param Profile profile:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_profile_with_http_info(factory_id, **kwargs)  # noqa: E501

    def create_profile_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Creates a Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_profile_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param Profile profile:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Profile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'profile']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_profile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `create_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'profile' in local_var_params:
            body_params = local_var_params['profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_video(self, factory_id, create_video_body, **kwargs):  # noqa: E501
        """Creates a Video from a provided source_url.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_video(factory_id, create_video_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param CreateVideoBody create_video_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Video
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_video_with_http_info(factory_id, create_video_body, **kwargs)  # noqa: E501

    def create_video_with_http_info(self, factory_id, create_video_body, **kwargs):  # noqa: E501
        """Creates a Video from a provided source_url.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_video_with_http_info(factory_id, create_video_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param CreateVideoBody create_video_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Video, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'create_video_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_video" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `create_video`")  # noqa: E501
        # verify the required parameter 'create_video_body' is set
        if self.api_client.client_side_validation and ('create_video_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_video_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_video_body` when calling `create_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_video_body' in local_var_params:
            body_params = local_var_params['create_video_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Video',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_encoding(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_encoding(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_encoding_with_http_info(encoding_id, factory_id, **kwargs)  # noqa: E501

    def delete_encoding_with_http_info(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Deletes an Encoding from both Telestream Cloud and your storage. Returns an information whether the operation was successful.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_encoding_with_http_info(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletedResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_encoding" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `delete_encoding`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `delete_encoding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_profile(self, profile_id, factory_id, **kwargs):  # noqa: E501
        """Deletes a given Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_profile(profile_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str profile_id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_profile_with_http_info(profile_id, factory_id, **kwargs)  # noqa: E501

    def delete_profile_with_http_info(self, profile_id, factory_id, **kwargs):  # noqa: E501
        """Deletes a given Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_profile_with_http_info(profile_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str profile_id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletedResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['profile_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_profile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'profile_id' is set
        if self.api_client.client_side_validation and ('profile_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['profile_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `profile_id` when calling `delete_profile`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `delete_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in local_var_params:
            path_params['profile_id'] = local_var_params['profile_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/{profile_id}.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_video(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Deletes a Video object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_video(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_video_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def delete_video_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Deletes a Video object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_video_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletedResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_video" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `delete_video`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `delete_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_video_source(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Delete a video's source file.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_video_source(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeletedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_video_source_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def delete_video_source_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Delete a video's source file.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_video_source_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeletedResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_video_source" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `delete_video_source`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `delete_video_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}/source.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def encodings_count(self, factory_id, **kwargs):  # noqa: E501
        """Returns a number of Encoding objects created using a given factory.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.encodings_count(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CountResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.encodings_count_with_http_info(factory_id, **kwargs)  # noqa: E501

    def encodings_count_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Returns a number of Encoding objects created using a given factory.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.encodings_count_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CountResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method encodings_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `encodings_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/count.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CountResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_encoding(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Returns an Encoding object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_encoding(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_encoding_with_http_info(encoding_id, factory_id, **kwargs)  # noqa: E501

    def get_encoding_with_http_info(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Returns an Encoding object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_encoding_with_http_info(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Encoding, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id', 'screenshots', 'precise_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_encoding" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `get_encoding`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `get_encoding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'screenshots' in local_var_params and local_var_params['screenshots'] is not None:  # noqa: E501
            query_params.append(('screenshots', local_var_params['screenshots']))  # noqa: E501
        if 'precise_status' in local_var_params and local_var_params['precise_status'] is not None:  # noqa: E501
            query_params.append(('precise_status', local_var_params['precise_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Encoding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_factory(self, id, **kwargs):  # noqa: E501
        """Returns a Factory object.  # noqa: E501

        Returns a Factory object.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_factory(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: id of a factory (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_factory_with_http_info(id, **kwargs)  # noqa: E501

    def get_factory_with_http_info(self, id, **kwargs):  # noqa: E501
        """Returns a Factory object.  # noqa: E501

        Returns a Factory object.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_factory_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: id of a factory (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Factory, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_factory" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `get_factory`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/factories/{id}.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Factory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_profile(self, profile_id, factory_id, **kwargs):  # noqa: E501
        """Returns a Profile object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_profile(profile_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str profile_id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_profile_with_http_info(profile_id, factory_id, **kwargs)  # noqa: E501

    def get_profile_with_http_info(self, profile_id, factory_id, **kwargs):  # noqa: E501
        """Returns a Profile object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_profile_with_http_info(profile_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str profile_id: Id of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Profile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['profile_id', 'factory_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_profile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'profile_id' is set
        if self.api_client.client_side_validation and ('profile_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['profile_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `profile_id` when calling `get_profile`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `get_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_id' in local_var_params:
            path_params['profile_id'] = local_var_params['profile_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'expand' in local_var_params and local_var_params['expand'] is not None:  # noqa: E501
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/{profile_id}.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_video(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a Video object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Video
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_video_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def get_video_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a Video object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Video, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_video" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `get_video`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `get_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Video',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_encodings(self, factory_id, **kwargs):  # noqa: E501
        """Returns a list of Encoding objects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_encodings(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param str video_id: Id of a Video. When specified, the resulting list will contain videos that belong to the Video.
        :param str status: One of `success`, `fail`, `processing`. When specified, the resulting list will contain ecodings filtered by status.
        :param str profile_id: Filter by profile_id.
        :param str profile_name: Filter by profile_name.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_encodings_with_http_info(factory_id, **kwargs)  # noqa: E501

    def list_encodings_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Returns a list of Encoding objects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_encodings_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param str video_id: Id of a Video. When specified, the resulting list will contain videos that belong to the Video.
        :param str status: One of `success`, `fail`, `processing`. When specified, the resulting list will contain ecodings filtered by status.
        :param str profile_id: Filter by profile_id.
        :param str profile_name: Filter by profile_name.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedEncodingsCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'video_id', 'status', 'profile_id', 'profile_name', 'page', 'per_page', 'screenshots', 'precise_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_encodings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `list_encodings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'video_id' in local_var_params and local_var_params['video_id'] is not None:  # noqa: E501
            query_params.append(('video_id', local_var_params['video_id']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'profile_id' in local_var_params and local_var_params['profile_id'] is not None:  # noqa: E501
            query_params.append(('profile_id', local_var_params['profile_id']))  # noqa: E501
        if 'profile_name' in local_var_params and local_var_params['profile_name'] is not None:  # noqa: E501
            query_params.append(('profile_name', local_var_params['profile_name']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501
        if 'screenshots' in local_var_params and local_var_params['screenshots'] is not None:  # noqa: E501
            query_params.append(('screenshots', local_var_params['screenshots']))  # noqa: E501
        if 'precise_status' in local_var_params and local_var_params['precise_status'] is not None:  # noqa: E501
            query_params.append(('precise_status', local_var_params['precise_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEncodingsCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_factories(self, **kwargs):  # noqa: E501
        """Returns a collection of Factory objects.  # noqa: E501

        Returns a collection of Factory objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_factories(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedFactoryCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_factories_with_http_info(**kwargs)  # noqa: E501

    def list_factories_with_http_info(self, **kwargs):  # noqa: E501
        """Returns a collection of Factory objects.  # noqa: E501

        Returns a collection of Factory objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_factories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedFactoryCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_factories" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/factories.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedFactoryCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_profiles(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Profile objects.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_profiles(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param bool exclude_advanced_services: Determine whether exclude Advanced Services profiles from the results. By default this is not set.
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedProfilesCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_profiles_with_http_info(factory_id, **kwargs)  # noqa: E501

    def list_profiles_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Profile objects.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_profiles_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param bool exclude_advanced_services: Determine whether exclude Advanced Services profiles from the results. By default this is not set.
        :param bool expand: If expand option is set Profile objects will contain all command parameters, even if their value is default. By default this is not set.
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedProfilesCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'exclude_advanced_services', 'expand', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_profiles" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `list_profiles`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'exclude_advanced_services' in local_var_params and local_var_params['exclude_advanced_services'] is not None:  # noqa: E501
            query_params.append(('exclude_advanced_services', local_var_params['exclude_advanced_services']))  # noqa: E501
        if 'expand' in local_var_params and local_var_params['expand'] is not None:  # noqa: E501
            query_params.append(('expand', local_var_params['expand']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedProfilesCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_video_encodings(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a list of Encodings that belong to a Video.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_video_encodings(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_video_encodings_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def list_video_encodings_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a list of Encodings that belong to a Video.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_video_encodings_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param bool screenshots: Determines whether the response will include screenshots. By default this is not set.
        :param bool precise_status: Determines whether the response will include a precise status. By default this is not set.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedEncodingsCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id', 'page', 'per_page', 'screenshots', 'precise_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_video_encodings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `list_video_encodings`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `list_video_encodings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501
        if 'screenshots' in local_var_params and local_var_params['screenshots'] is not None:  # noqa: E501
            query_params.append(('screenshots', local_var_params['screenshots']))  # noqa: E501
        if 'precise_status' in local_var_params and local_var_params['precise_status'] is not None:  # noqa: E501
            query_params.append(('precise_status', local_var_params['precise_status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}/encodings.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEncodingsCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_videos(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Video objects.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_videos(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedVideoCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_videos_with_http_info(factory_id, **kwargs)  # noqa: E501

    def list_videos_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Video objects.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_videos_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedVideoCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_videos" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `list_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedVideoCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_workflows(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Workflows that belong to a Factory.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workflows(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedWorkflowsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_workflows_with_http_info(factory_id, **kwargs)  # noqa: E501

    def list_workflows_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Workflows that belong to a Factory.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_workflows_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedWorkflowsCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_workflows" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `list_workflows`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/workflows.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedWorkflowsCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profile_encodings(self, id_or_name, factory_id, **kwargs):  # noqa: E501
        """Returns a list of Encodings that belong to a Profile.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profile_encodings(id_or_name, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id_or_name: Id or name of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedEncodingsCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.profile_encodings_with_http_info(id_or_name, factory_id, **kwargs)  # noqa: E501

    def profile_encodings_with_http_info(self, id_or_name, factory_id, **kwargs):  # noqa: E501
        """Returns a list of Encodings that belong to a Profile.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profile_encodings_with_http_info(id_or_name, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id_or_name: Id or name of a Profile. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedEncodingsCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id_or_name', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profile_encodings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id_or_name' is set
        if self.api_client.client_side_validation and ('id_or_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['id_or_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id_or_name` when calling `profile_encodings`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `profile_encodings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id_or_name' in local_var_params:
            path_params['id_or_name'] = local_var_params['id_or_name']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/{id_or_name}/encodings.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedEncodingsCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def queued_videos(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Video objects queued for encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.queued_videos(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PaginatedVideoCollection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.queued_videos_with_http_info(factory_id, **kwargs)  # noqa: E501

    def queued_videos_with_http_info(self, factory_id, **kwargs):  # noqa: E501
        """Returns a collection of Video objects queued for encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.queued_videos_with_http_info(factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param int page: A page to be fetched. Default is `1`.
        :param int per_page: A number of results per page. Default is `100`.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PaginatedVideoCollection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method queued_videos" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `queued_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'page' in local_var_params and local_var_params['page'] is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501
        if 'per_page' in local_var_params and local_var_params['per_page'] is not None:  # noqa: E501
            query_params.append(('per_page', local_var_params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/queued.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedVideoCollection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resubmit_video(self, factory_id, resubmit_video_body, **kwargs):  # noqa: E501
        """Resubmits a video to encode.  # noqa: E501

        Resubmits the video to encode. Please note that this option will work only for videos in `success` status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resubmit_video(factory_id, resubmit_video_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param ResubmitVideoBody resubmit_video_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.resubmit_video_with_http_info(factory_id, resubmit_video_body, **kwargs)  # noqa: E501

    def resubmit_video_with_http_info(self, factory_id, resubmit_video_body, **kwargs):  # noqa: E501
        """Resubmits a video to encode.  # noqa: E501

        Resubmits the video to encode. Please note that this option will work only for videos in `success` status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resubmit_video_with_http_info(factory_id, resubmit_video_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str factory_id: Id of a Factory. (required)
        :param ResubmitVideoBody resubmit_video_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['factory_id', 'resubmit_video_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resubmit_video" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `resubmit_video`")  # noqa: E501
        # verify the required parameter 'resubmit_video_body' is set
        if self.api_client.client_side_validation and ('resubmit_video_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['resubmit_video_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `resubmit_video_body` when calling `resubmit_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resubmit_video_body' in local_var_params:
            body_params = local_var_params['resubmit_video_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/resubmit.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retry_encoding(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Retries a failed encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retry_encoding(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RetriedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.retry_encoding_with_http_info(encoding_id, factory_id, **kwargs)  # noqa: E501

    def retry_encoding_with_http_info(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Retries a failed encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retry_encoding_with_http_info(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RetriedResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retry_encoding" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `retry_encoding`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `retry_encoding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}/retry.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RetriedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def signed_encoding_url(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Returns a signed url pointing to an Encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signed_encoding_url(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param int expires: Duration in seconds for validity period.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EncodingSignedUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.signed_encoding_url_with_http_info(encoding_id, factory_id, **kwargs)  # noqa: E501

    def signed_encoding_url_with_http_info(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Returns a signed url pointing to an Encoding.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signed_encoding_url_with_http_info(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param int expires: Duration in seconds for validity period.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EncodingSignedUrl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id', 'expires']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signed_encoding_url" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `signed_encoding_url`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `signed_encoding_url`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501
        if 'expires' in local_var_params and local_var_params['expires'] is not None:  # noqa: E501
            query_params.append(('expires', local_var_params['expires']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}/signed-url.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EncodingSignedUrl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def signed_encoding_urls(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Returns a list of signed urls pointing to an Encoding's outputs.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signed_encoding_urls(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EncodingSignedUrls
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.signed_encoding_urls_with_http_info(encoding_id, factory_id, **kwargs)  # noqa: E501

    def signed_encoding_urls_with_http_info(self, encoding_id, factory_id, **kwargs):  # noqa: E501
        """Returns a list of signed urls pointing to an Encoding's outputs.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signed_encoding_urls_with_http_info(encoding_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EncodingSignedUrls, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signed_encoding_urls" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `signed_encoding_urls`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `signed_encoding_urls`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}/signed-urls.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EncodingSignedUrls',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def signed_video_url(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a signed url pointing to a Video.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signed_video_url(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SignedVideoUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.signed_video_url_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def signed_video_url_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a signed url pointing to a Video.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signed_video_url_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SignedVideoUrl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signed_video_url" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `signed_video_url`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `signed_video_url`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}/signed-url.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SignedVideoUrl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_encoding(self, encoding_id, factory_id, update_encoding_body, **kwargs):  # noqa: E501
        """Updates an Encoding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_encoding(encoding_id, factory_id, update_encoding_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param UpdateEncodingBody update_encoding_body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Encoding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_encoding_with_http_info(encoding_id, factory_id, update_encoding_body, **kwargs)  # noqa: E501

    def update_encoding_with_http_info(self, encoding_id, factory_id, update_encoding_body, **kwargs):  # noqa: E501
        """Updates an Encoding  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_encoding_with_http_info(encoding_id, factory_id, update_encoding_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str encoding_id: Id of an Encoding. (required)
        :param str factory_id: Id of a Factory. (required)
        :param UpdateEncodingBody update_encoding_body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Encoding, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['encoding_id', 'factory_id', 'update_encoding_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_encoding" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'encoding_id' is set
        if self.api_client.client_side_validation and ('encoding_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['encoding_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `encoding_id` when calling `update_encoding`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `update_encoding`")  # noqa: E501
        # verify the required parameter 'update_encoding_body' is set
        if self.api_client.client_side_validation and ('update_encoding_body' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_encoding_body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_encoding_body` when calling `update_encoding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'encoding_id' in local_var_params:
            path_params['encoding_id'] = local_var_params['encoding_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_encoding_body' in local_var_params:
            body_params = local_var_params['update_encoding_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/encodings/{encoding_id}.json', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Encoding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_factory(self, id, **kwargs):  # noqa: E501
        """Updates a Factory's settings. Returns a Factory object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_factory(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: id of the factory (required)
        :param Factory factory:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Factory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_factory_with_http_info(id, **kwargs)  # noqa: E501

    def update_factory_with_http_info(self, id, **kwargs):  # noqa: E501
        """Updates a Factory's settings. Returns a Factory object.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_factory_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: id of the factory (required)
        :param Factory factory:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Factory, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'factory']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_factory" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `update_factory`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'factory' in local_var_params:
            body_params = local_var_params['factory']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/factories/{id}.json', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Factory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_profile(self, id, factory_id, **kwargs):  # noqa: E501
        """Updates a given Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_profile(id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: (required)
        :param str factory_id: Id of a Factory. (required)
        :param Profile profile:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_profile_with_http_info(id, factory_id, **kwargs)  # noqa: E501

    def update_profile_with_http_info(self, id, factory_id, **kwargs):  # noqa: E501
        """Updates a given Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_profile_with_http_info(id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: (required)
        :param str factory_id: Id of a Factory. (required)
        :param Profile profile:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Profile, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'factory_id', 'profile']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_profile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `update_profile`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `update_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'profile' in local_var_params:
            body_params = local_var_params['profile']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/profiles/{profile_id}.json', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def video_metadata(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a Video's metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.video_metadata(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.video_metadata_with_http_info(video_id, factory_id, **kwargs)  # noqa: E501

    def video_metadata_with_http_info(self, video_id, factory_id, **kwargs):  # noqa: E501
        """Returns a Video's metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.video_metadata_with_http_info(video_id, factory_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str video_id: Id of a Video. (required)
        :param str factory_id: Id of a Factory. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(dict(str, object), status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['video_id', 'factory_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method video_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'video_id' is set
        if self.api_client.client_side_validation and ('video_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['video_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `video_id` when calling `video_metadata`")  # noqa: E501
        # verify the required parameter 'factory_id' is set
        if self.api_client.client_side_validation and ('factory_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['factory_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `factory_id` when calling `video_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'video_id' in local_var_params:
            path_params['video_id'] = local_var_params['video_id']  # noqa: E501

        query_params = []
        if 'factory_id' in local_var_params and local_var_params['factory_id'] is not None:  # noqa: E501
            query_params.append(('factory_id', local_var_params['factory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKey']  # noqa: E501

        return self.api_client.call_api(
            '/videos/{video_id}/metadata.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
