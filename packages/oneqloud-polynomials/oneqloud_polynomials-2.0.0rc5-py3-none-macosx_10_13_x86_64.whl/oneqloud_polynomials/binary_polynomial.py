# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.11qdk
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_binary_polynomial')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_binary_polynomial')
    _binary_polynomial = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_binary_polynomial', [dirname(__file__)])
        except ImportError:
            import _binary_polynomial
            return _binary_polynomial
        try:
            _mod = imp.load_module('_binary_polynomial', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _binary_polynomial = swig_import_helper()
    del swig_import_helper
else:
    import _binary_polynomial
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _binary_polynomial.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _binary_polynomial.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _binary_polynomial.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _binary_polynomial.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _binary_polynomial.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _binary_polynomial.SwigPyIterator_equal(self, x)

    def copy(self):
        return _binary_polynomial.SwigPyIterator_copy(self)

    def next(self):
        return _binary_polynomial.SwigPyIterator_next(self)

    def __next__(self):
        return _binary_polynomial.SwigPyIterator___next__(self)

    def previous(self):
        return _binary_polynomial.SwigPyIterator_previous(self)

    def advance(self, n):
        return _binary_polynomial.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _binary_polynomial.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _binary_polynomial.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _binary_polynomial.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _binary_polynomial.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _binary_polynomial.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _binary_polynomial.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _binary_polynomial.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _binary_polynomial.SHARED_PTR_DISOWN

_qdk = _binary_polynomial

class PairUInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairUInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairUInt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _binary_polynomial.new_PairUInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _binary_polynomial.PairUInt_first_set
    __swig_getmethods__["first"] = _binary_polynomial.PairUInt_first_get
    if _newclass:
        first = _swig_property(_binary_polynomial.PairUInt_first_get, _binary_polynomial.PairUInt_first_set)
    __swig_setmethods__["second"] = _binary_polynomial.PairUInt_second_set
    __swig_getmethods__["second"] = _binary_polynomial.PairUInt_second_get
    if _newclass:
        second = _swig_property(_binary_polynomial.PairUInt_second_get, _binary_polynomial.PairUInt_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _binary_polynomial.delete_PairUInt
    __del__ = lambda self: None
PairUInt_swigregister = _binary_polynomial.PairUInt_swigregister
PairUInt_swigregister(PairUInt)

class VectorPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPair, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorPair_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorPair___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorPair___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorPair___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorPair___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorPair___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorPair___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorPair___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorPair___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorPair___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorPair_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorPair_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorPair_empty(self)

    def size(self):
        return _binary_polynomial.VectorPair_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorPair_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorPair_begin(self)

    def end(self):
        return _binary_polynomial.VectorPair_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorPair_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorPair_rend(self)

    def clear(self):
        return _binary_polynomial.VectorPair_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorPair_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorPair_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorPair_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorPair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorPair_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorPair_front(self)

    def back(self):
        return _binary_polynomial.VectorPair_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorPair_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorPair_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorPair_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorPair_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorPair_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorPair
    __del__ = lambda self: None
VectorPair_swigregister = _binary_polynomial.VectorPair_swigregister
VectorPair_swigregister(VectorPair)

class VectorUint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUint, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorUint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorUint___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorUint___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorUint___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorUint___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorUint___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorUint___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorUint___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorUint___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorUint___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorUint_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorUint_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorUint_empty(self)

    def size(self):
        return _binary_polynomial.VectorUint_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorUint_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorUint_begin(self)

    def end(self):
        return _binary_polynomial.VectorUint_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorUint_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorUint_rend(self)

    def clear(self):
        return _binary_polynomial.VectorUint_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorUint_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorUint_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorUint_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorUint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorUint_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorUint_front(self)

    def back(self):
        return _binary_polynomial.VectorUint_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorUint_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorUint_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorUint_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorUint_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorUint_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorUint
    __del__ = lambda self: None
VectorUint_swigregister = _binary_polynomial.VectorUint_swigregister
VectorUint_swigregister(VectorUint)

class VectorInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorInt___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorInt___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorInt___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorInt___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorInt___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorInt___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorInt_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorInt_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorInt_empty(self)

    def size(self):
        return _binary_polynomial.VectorInt_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorInt_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorInt_begin(self)

    def end(self):
        return _binary_polynomial.VectorInt_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorInt_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorInt_rend(self)

    def clear(self):
        return _binary_polynomial.VectorInt_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorInt_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorInt_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorInt_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorInt_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorInt_front(self)

    def back(self):
        return _binary_polynomial.VectorInt_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorInt_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorInt_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorInt_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorInt_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorInt_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorInt
    __del__ = lambda self: None
VectorInt_swigregister = _binary_polynomial.VectorInt_swigregister
VectorInt_swigregister(VectorInt)

class VectorByte(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorByte, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorByte, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorByte_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorByte___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorByte___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorByte___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorByte___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorByte___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorByte___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorByte___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorByte___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorByte___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorByte_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorByte_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorByte_empty(self)

    def size(self):
        return _binary_polynomial.VectorByte_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorByte_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorByte_begin(self)

    def end(self):
        return _binary_polynomial.VectorByte_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorByte_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorByte_rend(self)

    def clear(self):
        return _binary_polynomial.VectorByte_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorByte_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorByte_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorByte_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorByte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorByte_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorByte_front(self)

    def back(self):
        return _binary_polynomial.VectorByte_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorByte_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorByte_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorByte_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorByte_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorByte_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorByte
    __del__ = lambda self: None
VectorByte_swigregister = _binary_polynomial.VectorByte_swigregister
VectorByte_swigregister(VectorByte)

class MapUIntBool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MapUIntBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MapUIntBool, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.MapUIntBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.MapUIntBool___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.MapUIntBool___bool__(self)

    def __len__(self):
        return _binary_polynomial.MapUIntBool___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _binary_polynomial.MapUIntBool___getitem__(self, key)

    def __delitem__(self, key):
        return _binary_polynomial.MapUIntBool___delitem__(self, key)

    def has_key(self, key):
        return _binary_polynomial.MapUIntBool_has_key(self, key)

    def keys(self):
        return _binary_polynomial.MapUIntBool_keys(self)

    def values(self):
        return _binary_polynomial.MapUIntBool_values(self)

    def items(self):
        return _binary_polynomial.MapUIntBool_items(self)

    def __contains__(self, key):
        return _binary_polynomial.MapUIntBool___contains__(self, key)

    def key_iterator(self):
        return _binary_polynomial.MapUIntBool_key_iterator(self)

    def value_iterator(self):
        return _binary_polynomial.MapUIntBool_value_iterator(self)

    def __setitem__(self, *args):
        return _binary_polynomial.MapUIntBool___setitem__(self, *args)

    def asdict(self):
        return _binary_polynomial.MapUIntBool_asdict(self)

    def __init__(self, *args):
        this = _binary_polynomial.new_MapUIntBool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _binary_polynomial.MapUIntBool_empty(self)

    def size(self):
        return _binary_polynomial.MapUIntBool_size(self)

    def swap(self, v):
        return _binary_polynomial.MapUIntBool_swap(self, v)

    def begin(self):
        return _binary_polynomial.MapUIntBool_begin(self)

    def end(self):
        return _binary_polynomial.MapUIntBool_end(self)

    def rbegin(self):
        return _binary_polynomial.MapUIntBool_rbegin(self)

    def rend(self):
        return _binary_polynomial.MapUIntBool_rend(self)

    def clear(self):
        return _binary_polynomial.MapUIntBool_clear(self)

    def get_allocator(self):
        return _binary_polynomial.MapUIntBool_get_allocator(self)

    def count(self, x):
        return _binary_polynomial.MapUIntBool_count(self, x)

    def erase(self, *args):
        return _binary_polynomial.MapUIntBool_erase(self, *args)

    def find(self, x):
        return _binary_polynomial.MapUIntBool_find(self, x)

    def lower_bound(self, x):
        return _binary_polynomial.MapUIntBool_lower_bound(self, x)

    def upper_bound(self, x):
        return _binary_polynomial.MapUIntBool_upper_bound(self, x)
    __swig_destroy__ = _binary_polynomial.delete_MapUIntBool
    __del__ = lambda self: None
MapUIntBool_swigregister = _binary_polynomial.MapUIntBool_swigregister
MapUIntBool_swigregister(MapUIntBool)

class Hobo2Qubo_Constraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hobo2Qubo_Constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Hobo2Qubo_Constraint, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.Hobo2Qubo_Constraint___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.Hobo2Qubo_Constraint___bool__(self)

    def __len__(self):
        return _binary_polynomial.Hobo2Qubo_Constraint___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.Hobo2Qubo_Constraint___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.Hobo2Qubo_Constraint___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_pop(self)

    def append(self, x):
        return _binary_polynomial.Hobo2Qubo_Constraint_append(self, x)

    def empty(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_empty(self)

    def size(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_size(self)

    def swap(self, v):
        return _binary_polynomial.Hobo2Qubo_Constraint_swap(self, v)

    def begin(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_begin(self)

    def end(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_end(self)

    def rbegin(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_rbegin(self)

    def rend(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_rend(self)

    def clear(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_clear(self)

    def get_allocator(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_Hobo2Qubo_Constraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.Hobo2Qubo_Constraint_push_back(self, x)

    def front(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_front(self)

    def back(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_back(self)

    def assign(self, n, x):
        return _binary_polynomial.Hobo2Qubo_Constraint_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.Hobo2Qubo_Constraint_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_Hobo2Qubo_Constraint
    __del__ = lambda self: None
Hobo2Qubo_Constraint_swigregister = _binary_polynomial.Hobo2Qubo_Constraint_swigregister
Hobo2Qubo_Constraint_swigregister(Hobo2Qubo_Constraint)

class IsingJ(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsingJ, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsingJ, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.IsingJ_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.IsingJ___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.IsingJ___bool__(self)

    def __len__(self):
        return _binary_polynomial.IsingJ___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _binary_polynomial.IsingJ___getitem__(self, key)

    def __delitem__(self, key):
        return _binary_polynomial.IsingJ___delitem__(self, key)

    def has_key(self, key):
        return _binary_polynomial.IsingJ_has_key(self, key)

    def keys(self):
        return _binary_polynomial.IsingJ_keys(self)

    def values(self):
        return _binary_polynomial.IsingJ_values(self)

    def items(self):
        return _binary_polynomial.IsingJ_items(self)

    def __contains__(self, key):
        return _binary_polynomial.IsingJ___contains__(self, key)

    def key_iterator(self):
        return _binary_polynomial.IsingJ_key_iterator(self)

    def value_iterator(self):
        return _binary_polynomial.IsingJ_value_iterator(self)

    def __setitem__(self, *args):
        return _binary_polynomial.IsingJ___setitem__(self, *args)

    def asdict(self):
        return _binary_polynomial.IsingJ_asdict(self)

    def __init__(self, *args):
        this = _binary_polynomial.new_IsingJ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _binary_polynomial.IsingJ_empty(self)

    def size(self):
        return _binary_polynomial.IsingJ_size(self)

    def swap(self, v):
        return _binary_polynomial.IsingJ_swap(self, v)

    def begin(self):
        return _binary_polynomial.IsingJ_begin(self)

    def end(self):
        return _binary_polynomial.IsingJ_end(self)

    def rbegin(self):
        return _binary_polynomial.IsingJ_rbegin(self)

    def rend(self):
        return _binary_polynomial.IsingJ_rend(self)

    def clear(self):
        return _binary_polynomial.IsingJ_clear(self)

    def get_allocator(self):
        return _binary_polynomial.IsingJ_get_allocator(self)

    def count(self, x):
        return _binary_polynomial.IsingJ_count(self, x)

    def erase(self, *args):
        return _binary_polynomial.IsingJ_erase(self, *args)

    def find(self, x):
        return _binary_polynomial.IsingJ_find(self, x)

    def lower_bound(self, x):
        return _binary_polynomial.IsingJ_lower_bound(self, x)

    def upper_bound(self, x):
        return _binary_polynomial.IsingJ_upper_bound(self, x)
    __swig_destroy__ = _binary_polynomial.delete_IsingJ
    __del__ = lambda self: None
IsingJ_swigregister = _binary_polynomial.IsingJ_swigregister
IsingJ_swigregister(IsingJ)

class IsingH(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsingH, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsingH, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.IsingH_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.IsingH___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.IsingH___bool__(self)

    def __len__(self):
        return _binary_polynomial.IsingH___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _binary_polynomial.IsingH___getitem__(self, key)

    def __delitem__(self, key):
        return _binary_polynomial.IsingH___delitem__(self, key)

    def has_key(self, key):
        return _binary_polynomial.IsingH_has_key(self, key)

    def keys(self):
        return _binary_polynomial.IsingH_keys(self)

    def values(self):
        return _binary_polynomial.IsingH_values(self)

    def items(self):
        return _binary_polynomial.IsingH_items(self)

    def __contains__(self, key):
        return _binary_polynomial.IsingH___contains__(self, key)

    def key_iterator(self):
        return _binary_polynomial.IsingH_key_iterator(self)

    def value_iterator(self):
        return _binary_polynomial.IsingH_value_iterator(self)

    def __setitem__(self, *args):
        return _binary_polynomial.IsingH___setitem__(self, *args)

    def asdict(self):
        return _binary_polynomial.IsingH_asdict(self)

    def __init__(self, *args):
        this = _binary_polynomial.new_IsingH(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _binary_polynomial.IsingH_empty(self)

    def size(self):
        return _binary_polynomial.IsingH_size(self)

    def swap(self, v):
        return _binary_polynomial.IsingH_swap(self, v)

    def begin(self):
        return _binary_polynomial.IsingH_begin(self)

    def end(self):
        return _binary_polynomial.IsingH_end(self)

    def rbegin(self):
        return _binary_polynomial.IsingH_rbegin(self)

    def rend(self):
        return _binary_polynomial.IsingH_rend(self)

    def clear(self):
        return _binary_polynomial.IsingH_clear(self)

    def get_allocator(self):
        return _binary_polynomial.IsingH_get_allocator(self)

    def count(self, x):
        return _binary_polynomial.IsingH_count(self, x)

    def erase(self, *args):
        return _binary_polynomial.IsingH_erase(self, *args)

    def find(self, x):
        return _binary_polynomial.IsingH_find(self, x)

    def lower_bound(self, x):
        return _binary_polynomial.IsingH_lower_bound(self, x)

    def upper_bound(self, x):
        return _binary_polynomial.IsingH_upper_bound(self, x)
    __swig_destroy__ = _binary_polynomial.delete_IsingH
    __del__ = lambda self: None
IsingH_swigregister = _binary_polynomial.IsingH_swigregister
IsingH_swigregister(IsingH)

class UPQuadraticBinaryPolynomial(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPQuadraticBinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPQuadraticBinaryPolynomial, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPQuadraticBinaryPolynomial_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPQuadraticBinaryPolynomial
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPQuadraticBinaryPolynomial()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPQuadraticBinaryPolynomial_swigregister = _binary_polynomial.UPQuadraticBinaryPolynomial_swigregister
UPQuadraticBinaryPolynomial_swigregister(UPQuadraticBinaryPolynomial)

class QuadraticBinaryPolynomial(_object):
    """

    This class builds and stores quadratic binary polynomials.
    Quadratic binary polynomial has terms of the form c * x_i * x_j and c * x_i.

    Attributes:
       constant_term (float): The value of the constant term.
       degree (int): The degree of the polynomial.
       term_count (int): The number of terms in the polynomial, including the
         quadratic terms.
       var_count (int): The number of variables occurring in the terms.
       fixed_vars (dict): A dictionary of variables to their fixed values.

    The constructor has the following signature: ::

        QuadraticBinaryPolynomial(self)



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QuadraticBinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QuadraticBinaryPolynomial, name)

    def __init__(self, *args):
        """

        This class builds and stores quadratic binary polynomials.
        Quadratic binary polynomial has terms of the form c * x_i * x_j and c * x_i.

        Attributes:
           constant_term (float): The value of the constant term.
           degree (int): The degree of the polynomial.
           term_count (int): The number of terms in the polynomial, including the
             quadratic terms.
           var_count (int): The number of variables occurring in the terms.
           fixed_vars (dict): A dictionary of variables to their fixed values.

        The constructor has the following signature: ::

            QuadraticBinaryPolynomial(self)



        """
        this = _binary_polynomial.new_QuadraticBinaryPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def equals(self, other, epsilon=1e-9):
        """

        Compare two QUBOs, deep equality.

        The function has the following signature: ::

            equals(self, other)
            equals(self, other, epsilon)

        Args:
            other (QuadraticBinaryPolynomial): The polynomial to compare.
            epsilon (float): The precision used in comparing the coefficients
              (default '1e-9').

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_equals(self, other, epsilon)


    def add_term(self, *args):
        """

        Adds a term coeff * x_i * x_j to the current polynomial. If no variables are
        specified then the coefficient is added as a constant term. If a single variable
        is specified, or if both variables are the same, then a linear term is added.
        Otherwise a quadratic term is added.

        The function has the following signature: ::

            add_term(self, coeff)
            add_term(self, coeff, i)
            add_term(self, coeff, i, j)

        Args:
            coeff (float): The coefficient of the term.
            i (int): The index of first variable.
            j (int): The index of second variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_add_term(self, *args)


    def add_constant_term(self, value):
        """

        Increment the value of the constant term.

        The function has the following signature: ::

            add_constant_term(value)

        Args:
            value (float): The value added to the constant term.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_add_constant_term(self, value)


    def has_term(self, i, j):
        """

        This allows user to check if a certain term is already added to the polynomial.

        The function has the following signature: ::

            has_term(self, i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable.
                     Use same value for i, j if the term has one only variable.

        Returns:
            bool: True if the term x_i * x_j is already added to the polynomial.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_has_term(self, i, j)


    def remove_var(self, index):
        """

        Remove a variable and all its associated terms from the current terms.

        The function has the following signature: ::

            remove_var(self, index)

        Args:
            index (int): The index of the variable to be removed.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_remove_var(self, index)


    def remove_term(self, i, j):
        """

        Remove a term from the current set of terms.

        The function has the following signature: ::

            remove_term(i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable.
                     Use same value for i, j if the term has only one variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_remove_term(self, i, j)


    def get_coefficient(self, first_index, second_index):
        """

        This allows user to get the current coefficient of a term in the polynomial.

        The function has the following signature: ::

            get_coefficient(self, i, j)

        Args:
            i (int): The Index of first variable.
            j (int): The Index of second variable.
                     Use same value for i, j if the term has only one variable.

        Returns:
            float: The current coefficient of the term.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_get_coefficient(self, first_index, second_index)


    def set_coefficient(self, coeff, i, j):
        """

        This allows user to set the coefficient of a term in the polynomial.

        The function has the following signature: ::

            set_coefficient(self, coeff, i, j)

        Args:
            coeff (float): The new value of the coefficient.
            i (int): The index of first variable.
            j (int): The index of second variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_set_coefficient(self, coeff, i, j)


    def _var_list(self):
        val = _binary_polynomial.QuadraticBinaryPolynomial__var_list(self)

        return list(val)


        return val


    def clone(self):
        return _binary_polynomial.QuadraticBinaryPolynomial_clone(self)

    def multiply(self, constant):
        """

        Multiply the current terms by a factor.

        The function has the following signature: ::

            multiply(self, constant)

        Args:
            constant (float): The multiplication factor.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_multiply(self, constant)


    def square(self):
        return _binary_polynomial.QuadraticBinaryPolynomial_square(self)

    def sum(self, other):
        """

        Adds the terms from the given polynomial to the current polynomial.

        The function has the following signature: ::

            sum(self, other)

            Args:
                other (QuadraticBinaryPolynomial): The polynomial to add to this polynomial.


        """
        return _binary_polynomial.QuadraticBinaryPolynomial_sum(self, other)


    def set_fixed_var(self, variable, value):
        """

        Sets the fixed value of a variable.

        The function has the following signatures: ::

            set_fixed_var(self, variable, value)

        Args:
            variable (int): The variable to fix.
            value (bool): The fixed value.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_set_fixed_var(self, variable, value)


    def _set_fixed_vars(self, vars):
      self.clear_fixed_vars()
      for (k, v) in vars.items():
        self.set_fixed_var(k, v)


    def remove_fixed_var(self, variable):
        """

        Removes the given variable from the set of fixed variables.

        The function has the following signatures: ::

            remove_fixed_var(self, variable)

        Args:
            variable (int): The variable to unfix.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_remove_fixed_var(self, variable)


    def clear_fixed_vars(self):
        """

        Clears all fixed variables.

        The function has the following signatures: ::

            clear_fixed_vars(self)


        """
        return _binary_polynomial.QuadraticBinaryPolynomial_clear_fixed_vars(self)


    def _get_fixed_vars(self):
        return _binary_polynomial.QuadraticBinaryPolynomial__get_fixed_vars(self)

    def evaluate(self, configuration):
        """

        Evaluates the polynomial for a given configuration and returns the energy.

        The function has the following signatures: ::

            evaluate(self, configuration)

        Args:
            configuration(dict): The mapping of variables to their assigned values.

        Return:
            double: The resulting energy value.

        Throws:
            RuntimeError: If the configuration does not contain a value for each
                variable in the polynomial.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_evaluate(self, configuration)


    def to_string(self, meta_data=False):
        """

        Converts this polynomial into a string.

        The function has the following signatures: ::

            to_string(self)
            to_string(self, meta_data)

        Args:
            meta_data (bool): If True, the string will contain meta data such as degree
              and num_terms (default 'False').

        Return:
            string: The string representation of this polynomial. If meta data is not
              set to true, the string is 0 if the polynomial is empty.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_to_string(self, meta_data)


    def export_json(self):
        """

        Retrieves the JSON representation of the QUBO to be used with the GRPC endpoint.

        The function has the following signature: ::

            export_json(self)

        Returns:
            str: A string representation of the QUBO in JSON.


        """
        return _binary_polynomial.QuadraticBinaryPolynomial_export_json(self)


    def export_array(self):
        """
        Returns an upper triangular matrix representation of the polynomial.
        Each term becomes an entry in the array.

        Columns correspond to sorted variable indices.

        Column 0 corresponds to the smallest variable index.

        Column n - 1 corresponds to the largest variable index.

        This function has the following signature: ::

            export_array(self)

        Returns:
            numpy.array: A 2D array representation of the
            ``QuadraticBinaryPolynomial``, whose shape is
            (``var_count``, ``var_count``)

        """

        try:
            import numpy as np
        except:
            raise Exception('Cannot import numpy')
            return

        num_count = self.var_count
        var_index_list = self.var_list
        var_size = len(var_index_list)

        array = np.zeros((num_count, num_count))

        for i in range(0, var_size):
            for j in range(i, var_size):
                coeff = self.get_coefficient(var_index_list[i], var_index_list[j])
                if coeff != 0:
                    array[i, j] = coeff

        return array


    def __repr__(self):
        return _binary_polynomial.QuadraticBinaryPolynomial___repr__(self)

    def __eq__(self, other):
        return _binary_polynomial.QuadraticBinaryPolynomial___eq__(self, other)

    def __iter__(self):
      vars = self.var_list
      for i in range(len(vars)):
        for j in range(i, len(vars)):
          loose_i = vars[i]
          loose_j = vars[j]
          coeff = self.get_coefficient(loose_i, loose_j)
          if coeff != 0.0:
            yield (coeff, loose_i, loose_j)


    __swig_getmethods__["fixed_vars"] = _qdk.QuadraticBinaryPolynomial__get_fixed_vars
    __swig_setmethods__["fixed_vars"] = _set_fixed_vars
    if _newclass: fixed_vars = _swig_property(
        _qdk.QuadraticBinaryPolynomial__get_fixed_vars,
        _set_fixed_vars)
    __swig_getmethods__["var_list"] = _var_list
    if _newclass: var_list = _swig_property(_var_list)

    __swig_setmethods__["constant_term"] = _binary_polynomial.QuadraticBinaryPolynomial_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.QuadraticBinaryPolynomial_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_constant_term_get, _binary_polynomial.QuadraticBinaryPolynomial_constant_term_set)
    __swig_getmethods__["degree"] = _binary_polynomial.QuadraticBinaryPolynomial_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_degree_get)
    __swig_getmethods__["term_count"] = _binary_polynomial.QuadraticBinaryPolynomial_term_count_get
    if _newclass:
        term_count = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_term_count_get)
    __swig_getmethods__["var_count"] = _binary_polynomial.QuadraticBinaryPolynomial_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_var_count_get)
    __swig_destroy__ = _binary_polynomial.delete_QuadraticBinaryPolynomial
    __del__ = lambda self: None
QuadraticBinaryPolynomial_swigregister = _binary_polynomial.QuadraticBinaryPolynomial_swigregister
QuadraticBinaryPolynomial_swigregister(QuadraticBinaryPolynomial)

class BinaryPolynomialTerm(_object):
    """

    This class stores ``BinaryPolynomial`` terms. A term is a coefficient and a set
    of variable indices.

    Attributes:
        coefficient (float): The coefficient of the term.
        degree (int): The degree of the term.
        var_list (list): List of the indices (int) of the variables in this term.

    The constructor has the following signature: ::

        BinaryPolynomialTerm(self, coeff, var_list)

    Args:
        coeff (float): The coefficient of this term.
        var_list (list): The list of indices (int) of the variables of this term.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryPolynomialTerm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryPolynomialTerm, name)

    def __init__(self, coeff, var_list):
        this = _binary_polynomial.new_BinaryPolynomialTerm(coeff, var_list)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, other):
        return _binary_polynomial.BinaryPolynomialTerm___eq__(self, other)

    def __ne__(self, other):
        return _binary_polynomial.BinaryPolynomialTerm___ne__(self, other)

    def __repr__(self):
        return _binary_polynomial.BinaryPolynomialTerm___repr__(self)
    __swig_destroy__ = _binary_polynomial.delete_BinaryPolynomialTerm
    __del__ = lambda self: None

    def _var_list(self):
        val = _binary_polynomial.BinaryPolynomialTerm__var_list(self)

        return list(val)


        return val


    def clone(self):
        """

        Clones the polynomial term.

        This function has the following signature: ::

            clone(self)

        returns:
            BinaryPolynomialTerm: Clone of the BinaryPolynomialTerm.

        """
        return _binary_polynomial.BinaryPolynomialTerm_clone(self)


    def multiply(self, constant):
        """

        Multiply the term by a factor.

        This function has the following signature: ::

            multiply(self, constant)

        Args:
            constant (float): The factor to be multiplied.

        """
        return _binary_polynomial.BinaryPolynomialTerm_multiply(self, constant)


    __swig_getmethods__["var_list"] = _var_list
    if _newclass: var_list = _swig_property(_var_list)

    __swig_setmethods__["coefficient"] = _binary_polynomial.BinaryPolynomialTerm_coefficient_set
    __swig_getmethods__["coefficient"] = _binary_polynomial.BinaryPolynomialTerm_coefficient_get
    if _newclass:
        coefficient = _swig_property(_binary_polynomial.BinaryPolynomialTerm_coefficient_get, _binary_polynomial.BinaryPolynomialTerm_coefficient_set)
    __swig_getmethods__["degree"] = _binary_polynomial.BinaryPolynomialTerm_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.BinaryPolynomialTerm_degree_get)
BinaryPolynomialTerm_swigregister = _binary_polynomial.BinaryPolynomialTerm_swigregister
BinaryPolynomialTerm_swigregister(BinaryPolynomialTerm)

class UPBinaryPolynomial(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPBinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPBinaryPolynomial, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPBinaryPolynomial_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPBinaryPolynomial
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPBinaryPolynomial()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPBinaryPolynomial_swigregister = _binary_polynomial.UPBinaryPolynomial_swigregister
UPBinaryPolynomial_swigregister(UPBinaryPolynomial)

class BPConstantIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BPConstantIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BPConstantIterator, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _binary_polynomial.new_BPConstantIterator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def inc(self):
        return _binary_polynomial.BPConstantIterator_inc(self)

    def deref(self):
        return _binary_polynomial.BPConstantIterator_deref(self)

    def equals(self, other):
        return _binary_polynomial.BPConstantIterator_equals(self, other)
    __swig_destroy__ = _binary_polynomial.delete_BPConstantIterator
    __del__ = lambda self: None
BPConstantIterator_swigregister = _binary_polynomial.BPConstantIterator_swigregister
BPConstantIterator_swigregister(BPConstantIterator)

class BinaryPolynomial(_object):
    """

    This class represents polynomial structures and is
    used for binary polynomials of degree greater than 2. For
    degree 2 polynomials, please use QuadraticBinaryPolynomial.

    Attributes:
        degree (int): The maximum degree among all the terms.
        constant_term (float): The value of the constant term.
        term_count (int): The number of terms in the polynomial.
        var_count (int): The number of variables occurring in the terms.
        var_list (list): The list of variable indices (int).

    The constructor has the following signature: ::

        BinaryPolynomial(self)


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryPolynomial, name)

    def __init__(self, *args):
        """

        This class represents polynomial structures and is
        used for binary polynomials of degree greater than 2. For
        degree 2 polynomials, please use QuadraticBinaryPolynomial.

        Attributes:
            degree (int): The maximum degree among all the terms.
            constant_term (float): The value of the constant term.
            term_count (int): The number of terms in the polynomial.
            var_count (int): The number of variables occurring in the terms.
            var_list (list): The list of variable indices (int).

        The constructor has the following signature: ::

            BinaryPolynomial(self)


        """
        this = _binary_polynomial.new_BinaryPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def equals(self, other, epsilon=1e-9):
        """

        Equality checking between BinaryPolynomial instances.

        This function has the following signature: ::

            equals(self, other, epsilon)

        Args:
            other (BinaryPolynomial): The binary polynomial to compare.
            epsilon (float): The precision used in comparing the coefficients (default '1e-9').

        Returns:
            bool: True if this == other, False otherwise.

        """
        return _binary_polynomial.BinaryPolynomial_equals(self, other, epsilon)


    def has_term(self, indices):
        """

        Checks whether the polynomial has a term with the given indices.

        This function has the following signature: ::

            has_term(self, indices)

        Args:
            indices (list): List of variable indices (int) of the requested term.
              ``[index_A, index_B, ...]``

        Returns:
            bool: True if there is a term with variables specified in indices
            (with any non-zero coefficient).

        """
        return _binary_polynomial.BinaryPolynomial_has_term(self, indices)


    def get_term(self, indices):
        """

        Returns a term from the polynomial with the specified indices.

        This function has the following signature: ::

            get_term(self, indices)

        Args:
            indices (list): The variable indices of the requested term.

        Returns:
            BinaryPolynomialTerm: A BinaryPolynomialTerm with variables
            matching the specified indices.


        """
        return _binary_polynomial.BinaryPolynomial_get_term(self, indices)


    def remove_term(self, indices):
        """

        Removes a term from the BinaryPolynomial with the specified indices.

        This function has the following signature: ::

            remove_term(self, indices)

        Args:
            indices (list): The variable indices of a term to be removed.

        """
        return _binary_polynomial.BinaryPolynomial_remove_term(self, indices)


    def get_coefficient(self, indices):
        """

        Returns the coefficient of a term from the BinaryPolynomial.

        This function has the following signature: ::

            get_coefficient(self, indices)

        Args:
            indices (list): The variable indices of the requested term.

        Returns:
            float: The coefficient of the term, with variables specified by the `indices`.
            Returns 0 if there is no term in the polynomial with the requested indices.

        """
        return _binary_polynomial.BinaryPolynomial_get_coefficient(self, indices)


    def set_coefficient(self, new_coeff, indices):
        """

        Sets the coefficient of a term specified by its variable indices.

        This function has the following signature: ::

            set_coefficient(self, new_coeff, indices)

        Args:
            new_coeff (float): The value of the new coefficient.
            indices (list): The variable indices of the term to be changed.

        """
        return _binary_polynomial.BinaryPolynomial_set_coefficient(self, new_coeff, indices)


    def add_constant_term(self, constant):
        """

        Adds to the value of the current constant term.

        This function has the following signature: ::

            add_constant_term(self, constant)

        Args:
            constant (float): The value to be added to the constant term..


        """
        return _binary_polynomial.BinaryPolynomial_add_constant_term(self, constant)


    def remove_var(self, index):
        """

        Remove all terms containing the corresponding variable index.

        This function has the following signature: ::

            remove_var(self, index)

        Args:
            index (int): Removes all terms containing the corresponding variable index.

        """
        return _binary_polynomial.BinaryPolynomial_remove_var(self, index)


    def _cbegin(self):
        return _binary_polynomial.BinaryPolynomial__cbegin(self)

    def _cend(self):
        return _binary_polynomial.BinaryPolynomial__cend(self)

    def multiply(self, *args):
        """

        Multiply each term in this `BinaryPolynomial` by a factor, or
        another `BinaryPolynomial`.

        This function has the following signatures: ::

            multiply(self, coeff)
            multiply(self, other)

        Args:
            coeff (float): The factor to be multiplied.
            other (BinaryPolynomial): The BinaryPolynomial to be multiplied.

        """
        return _binary_polynomial.BinaryPolynomial_multiply(self, *args)


    def power(self, exponent):
        """

        Raise BinaryPolynomial to the power of exponent in place.

        This function has the following signatures: ::

            power(self, exp)

        Args:
            exp (float): The exponent to be applied.

        """
        return _binary_polynomial.BinaryPolynomial_power(self, exponent)


    def sum(self, other):
        """

        Adds another BinaryPolnomial to this instance.

        This function has the following signature: ::

            sum(self, other)

        Args:
            other (BinaryPolynomial): The BinaryPolynomial to be added.

        """
        return _binary_polynomial.BinaryPolynomial_sum(self, other)


    def to_string(self, meta_data=False):
        """

        Converts this polynomial into a string.

        This function has the following signature: ::

            to_string(self)
            to_string(self, meta_data)

        Args:
            meta_data (bool): If True, the string will contain meta data such as degree
              and term count (default 'False').

        Returns:
            string: The string representation of this polynomial. If meta data is not
              set to true, the string is 0 if the polynomial is empty.

        """
        return _binary_polynomial.BinaryPolynomial_to_string(self, meta_data)


    def clone(self):
        """

        Clones the BinaryPolynomial.

        This function has the following signature: ::

            clone(self)

        Returns:
            The cloned BinaryPolynomial instance.

        """
        return _binary_polynomial.BinaryPolynomial_clone(self)


    def add_term(self, *args):
        """

        Add a term to the polynomial.

        This function has the following signature: ::

            add_term(self, coeff, sorted_indices)
            add_term(self, term)

        Args:
            coeff (float): The coefficient of the term.
            sorted_indices (list): Sorted list of indices (int) of terms to be added.
            term (list): List of indices (int) of terms to be added.

        """
        return _binary_polynomial.BinaryPolynomial_add_term(self, *args)


    def __eq__(self, other):
        """

        Equality checking between BinaryPolynomial instances. Note that
        the tolerance for equality checking is 1e-9.

        This function has the following signature: ::

            __eq__(other)

        Args:
            other (BinaryPolynomial): The BinaryPolynomial to be checked against.

        Returns:
            bool: Returns true if the current instance is equal to the given
            BinaryPolynomial instance.

        """
        return _binary_polynomial.BinaryPolynomial___eq__(self, other)


    def __ne__(self, other):
        return _binary_polynomial.BinaryPolynomial___ne__(self, other)

    def __len__(self):
        """

        Returns the number of terms in the BinaryPolynomial.

        This function has the following signature: ::

            __len__()

        Returns:
            int: The number of terms in the polynomial.

        """
        return _binary_polynomial.BinaryPolynomial___len__(self)


    def __repr__(self):
        """

        This function returns the string representation of the BinaryPolynomial.

        This function has the following signature: ::

            __repr__(self)

        Returns:
            str: The string representation of all the terms in the BinaryPolynomial.

        """
        return _binary_polynomial.BinaryPolynomial___repr__(self)


    def _var_list(self):
        val = _binary_polynomial.BinaryPolynomial__var_list(self)

        val = list(val)


        return val


    def __iter__(self):
        it = self._cbegin()

        while not it.equals(self._cend()):
            yield it.deref()
            it.inc()

    def __reduce__(self):
        terms = []
        for term in self:
          terms.append({ "coefficient" : term.coefficient, "var_list" : tuple(term.var_list)})

        ret = {
            "terms" : terms,
        }
        return self.__class__, (), ret

    def __setstate__(self, state):
        for term in state["terms"]:
          if len(term["var_list"]) > 0:
            self.add_term(term["coefficient"], term["var_list"])
          else:
            self.constant_term = term["coefficient"]

    __swig_getmethods__["var_list"] = _var_list
    if _newclass: var_list = _swig_property(_var_list)

    __swig_getmethods__["var_count"] = _binary_polynomial.BinaryPolynomial_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.BinaryPolynomial_var_count_get)
    __swig_getmethods__["term_count"] = _binary_polynomial.BinaryPolynomial_term_count_get
    if _newclass:
        term_count = _swig_property(_binary_polynomial.BinaryPolynomial_term_count_get)
    __swig_getmethods__["degree"] = _binary_polynomial.BinaryPolynomial_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.BinaryPolynomial_degree_get)
    __swig_setmethods__["constant_term"] = _binary_polynomial.BinaryPolynomial_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.BinaryPolynomial_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.BinaryPolynomial_constant_term_get, _binary_polynomial.BinaryPolynomial_constant_term_set)
    __swig_destroy__ = _binary_polynomial.delete_BinaryPolynomial
    __del__ = lambda self: None
BinaryPolynomial_swigregister = _binary_polynomial.BinaryPolynomial_swigregister
BinaryPolynomial_swigregister(BinaryPolynomial)

class UPIsingModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPIsingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPIsingModel, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPIsingModel_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPIsingModel
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPIsingModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPIsingModel_swigregister = _binary_polynomial.UPIsingModel_swigregister
UPIsingModel_swigregister(UPIsingModel)

class IsingModel(_object):
    """

    This class represents an Isingmodel, which supports operations
    such as multiplying a scalar, arithmetic addition of Ising models, and scaling
    coefficients. The Ising model is represented as a set of quadratic (J)
    terms, a set of linear (H) terms, and a constant term.

    Attributes:
        constant_term (float): The constant term of the Ising model.
        j_terms (dict): The upper triangular J matrix which holds the mapping of the
          quadratic terms (tuple of ints) and their corresponding coefficients
          (float) ``{(term_A, term_B):coeff_AB, (term_B, term_C):coeff_BC, ... }``.
        h_terms (dict): A dictionary which holds the linear terms (int) mapped to their
          corresponding coefficient (float) ``{term:coeff}``.
        var_count (int): The number of variables in this IsingModel.

    The constructor has the following signature: ::

        IsingModel(self)


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsingModel, name)

    def __repr__(self):
        return _binary_polynomial.IsingModel___repr__(self)

    def clone(self):
        """

        Clones the Ising model.

        This function has the following signature: ::

            clone(self)

        Returns:
            IsingModel: A deep copy of the Ising model.

        """
        return _binary_polynomial.IsingModel_clone(self)


    def __eq__(self, other):
        """

        Checks the equality of two Ising models.

        This function has the following signature: ::

            __eq__(self, other)

        Args:
            other (IsingModel): The other IsingModel to compare against.

        Returns:
            bool: Returns true if the Ising models are identical.

        """
        return _binary_polynomial.IsingModel___eq__(self, other)


    def __ne__(self, other):
        """

        Checks the non-equality of two Ising models.

        This function has the following signature: ::

            __ne__(self, other)

        Args:
            other (IsingModel): The other IsingModel to compare against.

        Returns:
            bool: Returns true if the Ising models are not identical.

        """
        return _binary_polynomial.IsingModel___ne__(self, other)


    def _get_j_terms(self):
        val = _binary_polynomial.IsingModel__get_j_terms(self)

        return val.asdict()


        return val


    def _get_h_terms(self):
        val = _binary_polynomial.IsingModel__get_h_terms(self)

        return val.asdict()


        return val


    def add_term(self, *args):
        """

        Add a term to the IsingModel.

        This function has the following signatures: ::

            add_term(self, coefficient, index)
            add_term(self, coefficient, index_i, index_j)

        Args:
            coefficient (float): The coefficient of this term.
            index (int): The variable index of the linear term.
            index_i (int): The first variable index of the quadratic term.
            index_j (int): The second variable index of the quadratic term.


        """
        return _binary_polynomial.IsingModel_add_term(self, *args)


    def get_coefficient(self, *args):
        """

        Get the coefficient for a given term in the IsingModel.

        This function has the following signature: ::

            get_coefficient(self, index)
            get_coefficient(self, index_i, index_j)

        Args:
            index (int): The variable index of the linear term.
            index_i (int): The first variable index of the quadratic term.
            index_j (int): The second variable index of the quadratic term.

        Returns:
            float: The coefficient of the given term.


        """
        return _binary_polynomial.IsingModel_get_coefficient(self, *args)


    def _set_j_terms(self, J):
        return _binary_polynomial.IsingModel__set_j_terms(self, J)

    def _set_h_terms(self, H):
        return _binary_polynomial.IsingModel__set_h_terms(self, H)

    def has_term(self, *args):
        """

        Determine whether a term exists in the IsingModel.

        This function has the following signature: ::

            has_term(self, index)
            has_term(self, index_i, index_j)

        Args:
            index (int): The variable index of the linear term.
            index_i (int): The first variable index of the quadratic term.
            index_j (int): The second variable index of the quadratic term.

        Returns:
            bool: Returns True if the term exists in the IsingModel.


        """
        return _binary_polynomial.IsingModel_has_term(self, *args)


    def sum(self, model):
        """

        Add an IsingModel to this model.
        this.H = this.H + model.H, this.J = this.J + model.J and
        this.constant_term = this.constant_term + model.constant_term.

        This function has the following signature: ::

            sum(self, model)

        Args:
            model (IsingModel): The IsingModel to add to this model.

        """
        return _binary_polynomial.IsingModel_sum(self, model)


    def multiply_scalar(self, value):
        """

        Multiplies a scalar value to each of the terms in the Ising model.

        This function has the following signature: ::

            multiply_scalar(self, scalar)

        Args:
            scalar (float): The value to multiply into the Ising model.

        """
        return _binary_polynomial.IsingModel_multiply_scalar(self, value)


    def fit_into_range(self, max_J, max_H):
        """

        Fits the coefficients of the Ising model into the range.
        This works under the assumption that the ranges are symmetric.
        If a negative value is passed in for either J, or H, its absolute
        value will be taken. If there are no J or H terms present in the Ising model,
        then its corresponding upper bound (max_J, or max_H) will have no effect.

        This function has the following signature: ::

            fit_into_range(self, model)

        Args:
            max_J (float): The upper bound for the allowable range of J.
            max_H (float): The upper bound for the allowable range of H.

        """
        return _binary_polynomial.IsingModel_fit_into_range(self, max_J, max_H)


    __swig_getmethods__["j_terms"] = _get_j_terms
    __swig_setmethods__["j_terms"] = (_set_j_terms)
    if _newclass: j_terms = _swig_property(_get_j_terms, _set_j_terms)

    __swig_getmethods__["h_terms"] = _get_h_terms
    __swig_setmethods__["h_terms"] = (_set_h_terms)
    if _newclass: h_terms = _swig_property(_get_h_terms, _set_h_terms)

    __swig_setmethods__["constant_term"] = _binary_polynomial.IsingModel_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.IsingModel_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.IsingModel_constant_term_get, _binary_polynomial.IsingModel_constant_term_set)
    __swig_getmethods__["var_count"] = _binary_polynomial.IsingModel_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.IsingModel_var_count_get)

    def __init__(self):
        """

        This class represents an Isingmodel, which supports operations
        such as multiplying a scalar, arithmetic addition of Ising models, and scaling
        coefficients. The Ising model is represented as a set of quadratic (J)
        terms, a set of linear (H) terms, and a constant term.

        Attributes:
            constant_term (float): The constant term of the Ising model.
            j_terms (dict): The upper triangular J matrix which holds the mapping of the
              quadratic terms (tuple of ints) and their corresponding coefficients
              (float) ``{(term_A, term_B):coeff_AB, (term_B, term_C):coeff_BC, ... }``.
            h_terms (dict): A dictionary which holds the linear terms (int) mapped to their
              corresponding coefficient (float) ``{term:coeff}``.
            var_count (int): The number of variables in this IsingModel.

        The constructor has the following signature: ::

            IsingModel(self)


        """
        this = _binary_polynomial.new_IsingModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _binary_polynomial.delete_IsingModel
    __del__ = lambda self: None
IsingModel_swigregister = _binary_polynomial.IsingModel_swigregister
IsingModel_swigregister(IsingModel)

class UPCompactQBP(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPCompactQBP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPCompactQBP, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPCompactQBP_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPCompactQBP
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPCompactQBP()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPCompactQBP_swigregister = _binary_polynomial.UPCompactQBP_swigregister
UPCompactQBP_swigregister(UPCompactQBP)

class CompactQBP(_object):
    """

    This class stores a quadratic binary polynomial using a compact representation
    for improved performance. Conversion of a QuadraticBinaryPolynomial to a
    compact representation is typically implicit during minimization and is not
    required to be explicitly done to get the performance gains.

    Coefficients in the polynomial may be referenced either with 'loose' variable
    labels, which correspond to the variable labels of the original
    QuadraticBinaryPolynomial, or 'compact' variable labels, which are assigned
    to each loose variable label in a sequential and contiguous ordering.

    Attributes:
      constant_term (float): The value of the constant term.
      degree (int): The degree of the polynomial
      var_count (int): The number of variables occuring in the polynomial.
      fixed_vars (dict): An immutable dictionary of variable to their fixed values.
        The variables will not exist in the polynomial as they were evaluated and
        collapsed into the remaining terms during the conversion to a compact
        representation.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompactQBP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompactQBP, name)

    def __init__(self, qbp):
        """

        This class stores a quadratic binary polynomial using a compact representation
        for improved performance. Conversion of a QuadraticBinaryPolynomial to a
        compact representation is typically implicit during minimization and is not
        required to be explicitly done to get the performance gains.

        Coefficients in the polynomial may be referenced either with 'loose' variable
        labels, which correspond to the variable labels of the original
        QuadraticBinaryPolynomial, or 'compact' variable labels, which are assigned
        to each loose variable label in a sequential and contiguous ordering.

        Attributes:
          constant_term (float): The value of the constant term.
          degree (int): The degree of the polynomial
          var_count (int): The number of variables occuring in the polynomial.
          fixed_vars (dict): An immutable dictionary of variable to their fixed values.
            The variables will not exist in the polynomial as they were evaluated and
            collapsed into the remaining terms during the conversion to a compact
            representation.

        """
        this = _binary_polynomial.new_CompactQBP(qbp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_compact_coefficient(self, compact_i, compact_j):
        """

        Get coefficient for a pair of compact variable label. Pass the same variable
        label for i and j to access the linear terms.

        The function has the following signature: ::

            get_compact_coefficient(i, j)

        Args:
            i (int): The first variable label.
            j (int): The second variable label.

        """
        return _binary_polynomial.CompactQBP_get_compact_coefficient(self, compact_i, compact_j)


    def get_loose_coefficient(self, loose_i, loose_j):
        """

        Get coefficient for a pair of loose variable label. Pass the same variable
        label for i and j to access the linear terms.

        The function has the following signature: ::

            get_loose_coefficient(i, j)

        Args:
            i (int): The first variable label.
            j (int): The second variable label.

        """
        return _binary_polynomial.CompactQBP_get_loose_coefficient(self, loose_i, loose_j)


    def set_compact_coefficient(self, coeff, compact_i, compact_j):
        """

        Set the coefficient for a pair of compact variable label. Pass the same variable
        label for i and j to modify the linear terms.

        The function has the following signature: ::

            set_compact_coefficient(new_coefficient, i, j)

        Args:
            new_coefficient (float): The new coefficient value.
            i (int): The first variable label.
            j (int): The second variable label.

        """
        return _binary_polynomial.CompactQBP_set_compact_coefficient(self, coeff, compact_i, compact_j)


    def set_loose_coefficient(self, coeff, loose_i, loose_j):
        """

        Set the coefficient for a pair of loose variable label. Pass the same variable
        label for i and j to modify the linear terms.

        The function has the following signature: ::

            set_loose_coefficient(new_coefficient, i, j)

        Args:
            new_coefficient (float): The new coefficient value.
            i (int): The first variable label.
            j (int): The second variable label.

        """
        return _binary_polynomial.CompactQBP_set_loose_coefficient(self, coeff, loose_i, loose_j)


    def loose_to_compact(self, loose_i):
        """

        Get the equivalent compact variable label for the given loose variable label.

        The function has the following signature: ::

            loose_to_compact(i)

        Args:
            i (int): The loose variable label to convert.

        """
        return _binary_polynomial.CompactQBP_loose_to_compact(self, loose_i)


    def compact_to_loose(self, compact_i):
        """

        Get the equivalent loose variable label for the given compact variable label.

        The function has the following signature: ::

            compact_to_loose(i)

        Args:
            i (int): The compact variable label to convert.

        """
        return _binary_polynomial.CompactQBP_compact_to_loose(self, compact_i)


    def multiply(self, constant):
        """

        Multiply all terms of the polynomial by the given factor.

        The function has the following signature: ::

            multiply(factor)

        Args:
            factor (float): The factor to multiply all terms in the polynomial by.

        """
        return _binary_polynomial.CompactQBP_multiply(self, constant)


    def _get_fixed_vars(self):
        return _binary_polynomial.CompactQBP__get_fixed_vars(self)

    def to_string(self, meta_data=False):
        """

        Converts this polynomial into a string.

        The function has the following signatures: ::

            to_string(self)
            to_string(self, meta_data)

        Args:
            meta_data (bool): If True, the string will contain meta data such as degree
              and num_terms (default 'False').

        Return:
            string: The string representation of this polynomial.

        """
        return _binary_polynomial.CompactQBP_to_string(self, meta_data)


    __swig_getmethods__["fixed_vars"] = _qdk.CompactQBP__get_fixed_vars
    if _newclass: fixed_vars = _swig_property(_qdk.CompactQBP__get_fixed_vars)


    def __repr__(self):
        return _binary_polynomial.CompactQBP___repr__(self)
    __swig_setmethods__["constant_term"] = _binary_polynomial.CompactQBP_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.CompactQBP_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.CompactQBP_constant_term_get, _binary_polynomial.CompactQBP_constant_term_set)
    __swig_getmethods__["var_count"] = _binary_polynomial.CompactQBP_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.CompactQBP_var_count_get)
    __swig_getmethods__["degree"] = _binary_polynomial.CompactQBP_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.CompactQBP_degree_get)
    __swig_destroy__ = _binary_polynomial.delete_CompactQBP
    __del__ = lambda self: None
CompactQBP_swigregister = _binary_polynomial.CompactQBP_swigregister
CompactQBP_swigregister(CompactQBP)

class Hobo2QuboAgent(_object):
    """

    An agent to interact between HOBO and QUBO.

    Attributes:
        constraint (list): Contains tuples of size 4. The tuple contains the auxiliary variable
            index (int), the two original variable indices (int), and the coefficient
            of the auxiliary variable (float).

    The constructor has the following signature: ::

        Hobo2QuboAgent(self, quad_builder)

    Args:
        quad_builder (QuadraticBinaryPolynomialBuilder): Used to build
            the QuadraticBinaryPolynomial.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hobo2QuboAgent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Hobo2QuboAgent, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _binary_polynomial.new_Hobo2QuboAgent()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def translate(self, hobo):
        return _binary_polynomial.Hobo2QuboAgent_translate(self, hobo)

    def _get_constraint(self):
        return _binary_polynomial.Hobo2QuboAgent__get_constraint(self)

    __swig_getmethods__["constraint"] = _get_constraint
    if _newclass: constraint = _swig_property(_get_constraint)

    __swig_destroy__ = _binary_polynomial.delete_Hobo2QuboAgent
    __del__ = lambda self: None
    __swig_getmethods__["var_count"] = _binary_polynomial.Hobo2QuboAgent_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.Hobo2QuboAgent_var_count_get)
Hobo2QuboAgent_swigregister = _binary_polynomial.Hobo2QuboAgent_swigregister
Hobo2QuboAgent_swigregister(Hobo2QuboAgent)

class UPPreprocessor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPPreprocessor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPPreprocessor, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPPreprocessor_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPPreprocessor
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPPreprocessor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPPreprocessor_swigregister = _binary_polynomial.UPPreprocessor_swigregister
UPPreprocessor_swigregister(UPPreprocessor)

class Preprocessor(_object):
    """

    This class allows preprocessing a polynomial to fix variables that can be
    determined to always be a certain value in optimal solutions.

    Attributes:
        only_unique_reductions (bool): If true then reductions will only be applied
            if they apply to every optimal solutions. If false then reductions that
            may only apply to some optimal solutions will also be allowed.
        num_shuffles (int): The number of iterations of the preprocessing to apply.
            As the order in which the preprocessing is applied affects which
            variables are fixed it can be beneficial to take the union of the
            results of multiple runs of the preprocessing with the order shuffled
            each time.
        random_seed (uint64_t): The random seed for the preprocessor. A seed of
            zero will cause the preprocessor to create a new random seed for every
            run.
        loop_count (int): The number of iterations taken to process the last
            polynomial.
        num_vars_fixed (int): The number of variables fixed while processing the
            last polynomial.
        last_random_seed (uint64_t): The last random seed used to process a
            polynomial, useful if the seed was randomized but you want to reproduce
            the last run.


    The constructor has the following signature: ::

        Preprocessor(self)



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Preprocessor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Preprocessor, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _binary_polynomial.new_Preprocessor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def process(self, polynomial):
        """

        Process the given polynomial applying reductions to fix variables if it can be
        determined that a variable has a certain value for all optimal solutions. The
        reduced variables are fixed directly in the given polynomial.

        The function has the following signature: ::

            process(self, polynomial)

        Args:
            polynomial (QuadraticBinaryPolynomial): The polynomial to process.

        """
        return _binary_polynomial.Preprocessor_process(self, polynomial)

    __swig_setmethods__["only_unique_reductions"] = _binary_polynomial.Preprocessor_only_unique_reductions_set
    __swig_getmethods__["only_unique_reductions"] = _binary_polynomial.Preprocessor_only_unique_reductions_get
    if _newclass:
        only_unique_reductions = _swig_property(_binary_polynomial.Preprocessor_only_unique_reductions_get, _binary_polynomial.Preprocessor_only_unique_reductions_set)
    __swig_setmethods__["num_shuffles"] = _binary_polynomial.Preprocessor_num_shuffles_set
    __swig_getmethods__["num_shuffles"] = _binary_polynomial.Preprocessor_num_shuffles_get
    if _newclass:
        num_shuffles = _swig_property(_binary_polynomial.Preprocessor_num_shuffles_get, _binary_polynomial.Preprocessor_num_shuffles_set)
    __swig_setmethods__["random_seed"] = _binary_polynomial.Preprocessor_random_seed_set
    __swig_getmethods__["random_seed"] = _binary_polynomial.Preprocessor_random_seed_get
    if _newclass:
        random_seed = _swig_property(_binary_polynomial.Preprocessor_random_seed_get, _binary_polynomial.Preprocessor_random_seed_set)
    __swig_getmethods__["loop_count"] = _binary_polynomial.Preprocessor_loop_count_get
    if _newclass:
        loop_count = _swig_property(_binary_polynomial.Preprocessor_loop_count_get)
    __swig_getmethods__["num_vars_fixed"] = _binary_polynomial.Preprocessor_num_vars_fixed_get
    if _newclass:
        num_vars_fixed = _swig_property(_binary_polynomial.Preprocessor_num_vars_fixed_get)
    __swig_getmethods__["last_random_seed"] = _binary_polynomial.Preprocessor_last_random_seed_get
    if _newclass:
        last_random_seed = _swig_property(_binary_polynomial.Preprocessor_last_random_seed_get)
    __swig_destroy__ = _binary_polynomial.delete_Preprocessor
    __del__ = lambda self: None
Preprocessor_swigregister = _binary_polynomial.Preprocessor_swigregister
Preprocessor_swigregister(Preprocessor)


def preprocess(polynomial):
    """

    Performs preprocessing on the given polynomial to find and fix variables which
    are calculated to always be fixed to a certain value for all minimal solutions.
    The resulting set of fixed variables are set as fixed in the given polynomial
    directly.

    This function has the following signatures: ::

        preprocess(polynomial)

    Args:
        polynomial (QuadraticBinaryPolynomial): The polynomial to process.


    """
    return _binary_polynomial.preprocess(polynomial)

def ising_from_qbp(qbp):
    """

    Gets an equivalent IsingModel from the given QuadraticBinaryPolynomial.

    This function has the following signatures: ::

        ising_from_qbp(qbp)

    Args:
        qbp (QuadraticBinaryPolynomial): The QuadraticBinaryPolynomial to convert.


    """
    return _binary_polynomial.ising_from_qbp(qbp)

def qbp_from_ising(ising):
    """

    Gets an equivalent QuadraticBinaryPolynomial from the given IsingModel.

    This function has the following signatures: ::

        qbp_from_ising(ising)

    Args:
        ising (IsingModel): The IsingModel to convert.


    """
    return _binary_polynomial.qbp_from_ising(ising)

def qbp_from_string(str):
    """

    Gets an equivalent QuadraticBinaryPolynomial from the given string

    The string representation supported is the same as the output from the to_string
        function of QuadraticBinaryPolynomial. An example is the string
        `2 x_2 x_3 + 4 x_4 - 7`. The whitespace between any terms is optional as are
        the underscores. The terms may be in any order.

    This function has the following signatures: ::

        qbp_from_string(string)

    Args:
        string (string): The string representation to convert.

    Raises:
        RuntimeError: If the input is not a valid string representation.


    """
    return _binary_polynomial.qbp_from_string(str)

def reduce_qbp_by_configuration(qbp, configuration):
    """

    Partially evaluate a QuadraticBinaryPolynomial using the given configuration
        and return a new QuadraticBinaryPolynomial

    Variables in the new QuadraticBinaryPolynomial are a subset of the
        variables in the original QuadraticBinaryPolynomial.
        Variables not appearing in the given configuration will not appear in the
        new QuadraticBinaryPolynomial.
        Variables appearing in the original QuadraticBinaryPolynomial and in the
        given configuration will be subsituted with the values in the given
        configuration.

    This function has the following signature: ::

        reduce_qbp_by_configuration(qbp, configuration)

    Args:
        qbp (QuadraticBinaryPolynomial): The QuadraticBinaryPolynomial to reduce.
        configuration (dict): The configuration used to reduce the QBP.

    Returns:
        QuadraticBinaryPolynomial: The new reduced QuadraticBinaryPolynomial.


    """
    return _binary_polynomial.reduce_qbp_by_configuration(qbp, configuration)

def qbp_from_numpy(array, var_list=None):
  """
  Creates a QuadraticBinaryPolynomial from the given numpy array or matrix.

  If a list of variable indices is provided the resulting polynomial's
  variable indices will be replaced with those in the list. The indices
  will be replaced in the same order as the list.

  Args:
    array (numpy.array or numpy.matrix): A 2D representation of the
      polynomial's coefficient matrix.
    var_list (list): (optional) variable indices.

  Node:
    ``array`` must be a N by N array and its dimensions must match the number
    of variables in ``var_list`` if provided.
  """

  import numpy
  if not isinstance(array, numpy.ndarray) and not isinstance(array, numpy.matrix):
    raise Exception('Array is not an object of type numpy.ndarray or numpy.matrix')
  if array.shape[0] != array.shape[1]:
    raise Exception('Array is not a square matrix')
  if var_list is None:
    var_list = [i for i in range(array.shape[0])]
  elif len(var_list) != array.shape[0]:
    raise Exception('Array dimensions must equal number of variables in var_list')

  poly = QuadraticBinaryPolynomial()
  var_count = array.shape[0]
  for i in range(var_count):
    loose_i = var_list[i]
    for j in range(var_count):
      loose_j = var_list[j]
      coeff = float(array[i, j])
      if coeff != 0:
        poly.add_term(coeff, loose_i, loose_j)
  return poly


def qbp_from_ising_matrix(array, var_list=None):
  """
  Creates a QuadraticBinaryPolynomial from the given numpy array or matrix.

  If a list of variable indices is provided the resulting polynomial's
  variable indices will be replaced with those in the list. The indices
  will be replaced in the same order as the list.

  Args:
    array (numpy.array or numpy.matrix): A 2D representation of the
      polynomial's coefficient matrix.
    var_list (list): (optional) variable indices.

  Node:
    ``array`` must be a N by N array and its dimensions must match the number
    of variables in ``var_list`` if provided.
  """

  import numpy
  if not isinstance(array, numpy.ndarray) and not isinstance(array, numpy.matrix):
    raise Exception('Array is not an object of type numpy.ndarray or numpy.matrix')
  if array.shape[0] != array.shape[1]:
    raise Exception('Array is not a square matrix')
  if var_list is None:
    var_list = [i for i in range(array.shape[0])]
  elif len(var_list) != array.shape[0]:
    raise Exception('Array dimensions must equal number of variables in var_list')

  var_count = array.shape[0]
  j_col_sums = [0 for x in range(var_count)]
  constant = 0.0
  for i in range(var_count):
    for j in range(var_count):
      coeff = float(array[i, j])
      if i == j:
# H term
        constant -= coeff
      else:
# J term
        constant += coeff
        j_col_sums[i] += coeff / 2
        j_col_sums[j] += coeff / 2

  poly = QuadraticBinaryPolynomial()
  poly.constant_term = constant
  for i in range(var_count):
    loose_i = var_list[i]
    for j in range(var_count):
      loose_j = var_list[j]
      coeff = float(array[i, j])
      if i == j:
# H term
        term = 2 * coeff - 4 * j_col_sums[i]
        poly.add_term(term, loose_i, loose_i)
      else:
# J term
        poly.add_term(4 * coeff, loose_i, loose_j)
  return poly

class PolynomialWriter(_object):
    """

    A class for writing a polynomial out to a file.

    Attributes:
       var_list_included (bool): If the variable labels are included with the
            polynomial.
       fixed_variables_included (bool): If any fixed variables on the
            polynomial should be written.

    The constructor has the following signature: ::

        PolynomialWriter(self, filename)


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolynomialWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolynomialWriter, name)
    __repr__ = _swig_repr

    def __init__(self, filename):
        """

        A class for writing a polynomial out to a file.

        Attributes:
           var_list_included (bool): If the variable labels are included with the
                polynomial.
           fixed_variables_included (bool): If any fixed variables on the
                polynomial should be written.

        The constructor has the following signature: ::

            PolynomialWriter(self, filename)


        """
        this = _binary_polynomial.new_PolynomialWriter(filename)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def save(self, *args):
        """

        Saves the given polynomial into the file. This finalizes the write and no
        further calls to save may be made to the same writer.

        The function has the following signature: ::

            save(self, poly)

        Args:
            poly (QuadraticBinaryPolynomial): The polynomial to save.

        """
        return _binary_polynomial.PolynomialWriter_save(self, *args)

    __swig_setmethods__["var_list_included"] = _binary_polynomial.PolynomialWriter_var_list_included_set
    __swig_getmethods__["var_list_included"] = _binary_polynomial.PolynomialWriter_var_list_included_get
    if _newclass:
        var_list_included = _swig_property(_binary_polynomial.PolynomialWriter_var_list_included_get, _binary_polynomial.PolynomialWriter_var_list_included_set)
    __swig_setmethods__["fixed_variables_included"] = _binary_polynomial.PolynomialWriter_fixed_variables_included_set
    __swig_getmethods__["fixed_variables_included"] = _binary_polynomial.PolynomialWriter_fixed_variables_included_get
    if _newclass:
        fixed_variables_included = _swig_property(_binary_polynomial.PolynomialWriter_fixed_variables_included_get, _binary_polynomial.PolynomialWriter_fixed_variables_included_set)
    __swig_destroy__ = _binary_polynomial.delete_PolynomialWriter
    __del__ = lambda self: None
PolynomialWriter_swigregister = _binary_polynomial.PolynomialWriter_swigregister
PolynomialWriter_swigregister(PolynomialWriter)

class PolynomialReader(_object):
    """

    A class for reading a polynomial out of a file.

    The constructor has the following signature: ::

        PolynomialReader(self, filename)


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolynomialReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolynomialReader, name)
    __repr__ = _swig_repr

    def __init__(self, filename):
        """

        A class for reading a polynomial out of a file.

        The constructor has the following signature: ::

            PolynomialReader(self, filename)


        """
        this = _binary_polynomial.new_PolynomialReader(filename)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def load(self):
        """

        Finishes loading the polynomial and returns the result. Only one polynomial is
        stored per file and repeated calls to load will result in an error.

        The function has the following signature: ::

            load(self)

        Returns:
            QuadraticBinaryPolynomial: The loaded polynomial.

        """
        return _binary_polynomial.PolynomialReader_load(self)


    def load_compact(self):
        return _binary_polynomial.PolynomialReader_load_compact(self)
    __swig_destroy__ = _binary_polynomial.delete_PolynomialReader
    __del__ = lambda self: None
PolynomialReader_swigregister = _binary_polynomial.PolynomialReader_swigregister
PolynomialReader_swigregister(PolynomialReader)

class VectorQbp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorQbp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorQbp, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorQbp_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorQbp___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorQbp___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorQbp___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorQbp___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorQbp___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorQbp___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorQbp___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorQbp___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorQbp___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorQbp_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorQbp_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorQbp_empty(self)

    def size(self):
        return _binary_polynomial.VectorQbp_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorQbp_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorQbp_begin(self)

    def end(self):
        return _binary_polynomial.VectorQbp_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorQbp_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorQbp_rend(self)

    def clear(self):
        return _binary_polynomial.VectorQbp_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorQbp_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorQbp_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorQbp_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorQbp(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorQbp_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorQbp_front(self)

    def back(self):
        return _binary_polynomial.VectorQbp_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorQbp_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorQbp_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorQbp_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorQbp_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorQbp_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorQbp
    __del__ = lambda self: None
VectorQbp_swigregister = _binary_polynomial.VectorQbp_swigregister
VectorQbp_swigregister(VectorQbp)


def get_connected_subpolynomials(qbp):
    return _binary_polynomial.get_connected_subpolynomials(qbp)
get_connected_subpolynomials = _binary_polynomial.get_connected_subpolynomials
# This file is compatible with both classic and new-style classes.


