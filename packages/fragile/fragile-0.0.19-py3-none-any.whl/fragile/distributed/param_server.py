from collections import deque
import copy

from fragile.core.utils import random_state
from fragile.distributed.export_swarm import ExportedWalkers


class BestWalker(ExportedWalkers):
    """Represent the best walker found during a distributed search process run \
    with several :class:`ExportSwarm`."""

    def __init__(self, minimize: bool = False):
        """
        Initialize a :class:`BestWalker`.

        Args:
            minimize: If ``True`` the walker represents a minimization process.
        """
        super(BestWalker, self).__init__(1)
        self.minimize = minimize

    def update_best(self, walkers: ExportedWalkers):
        """
        Update the values tracked by the walker if the passed \
        :class:`ExternalWalkers` contain  a better value.

        Args:
            walkers: The current best values will be compared against the \
                     walkers of this instance of :class:`ExportedWalkers`.

        Returns:
            None

        """
        curr_best = self.get_best_reward(self.minimize)
        other_best = walkers.get_best_reward(self.minimize)
        other_improves = curr_best > other_best if self.minimize else curr_best < other_best
        if other_improves:
            ix = walkers.get_best_index(self.minimize)
            self.states = copy.deepcopy(walkers.states[ix])
            self.observs = copy.deepcopy(walkers.observs[ix])
            self.rewards = copy.deepcopy(walkers.rewards[ix])
            self.id_walkers = copy.deepcopy(walkers.id_walkers[ix])


class ParamServer:
    """
    Parameter server that stores the :class:`ExportedWalkers` generated by \
    different :class:`ExportSwarm`.

    It allows different :class:`ExportSwarm` to exchange walkers, and it keeps \
    track of the best walker found during the search process.
    """

    def __init__(self, max_len: int = 20, minimize: bool = False, add_global_best: bool = True):
        """
        Initialize a :class:`ParamServer`.

        Args:
            max_len: Maximum number of :class:`ExportedWalkers` that the \
                     :class:`ParamServer` will keep in its buffer.
            minimize: ``True`` if the :class:`ParamServer` will be used for a \
                       minimization process, ``False`` if it will be used for a \
                       maximization process.
            add_global_best: Add the best value found during the search to all \
                             the exported walkers that the :class:`ParamServer` \
                             returns.

        """
        self._max_len = max_len
        self.add_global_best = add_global_best
        self.minimize = minimize
        self.buffer = deque([], self._max_len)
        self.best = BestWalker(minimize=self.minimize)

    def __len__(self) -> int:
        """Return the length of the internal buffer."""
        return len(self.buffer)

    @property
    def max_len(self) -> int:
        """Return the maximum length of the internal buffer."""
        return self._max_len

    def reset(self):
        """Erase the internal data of the :class:`ParamServer`."""
        self.buffer = deque([], self._max_len)
        self.best = BestWalker(minimize=self.minimize)

    def exchange_walkers(self, walkers: ExportedWalkers) -> ExportedWalkers:
        """
        Store a new instance of :class:`ExportedWalkers` and return on of the \
        walkers stored in the internal buffer.

        If ``self.add_global_best`` is ``True`` the best walker found will be \
        included in the returned :class:`ExportedWalkers`.

        Args:
            walkers: Data that will be stored in the internal buffer.

        Returns:
            :class:`ExportedWalkers` sampled randomly from the internal buffer.

        """
        self.import_walkers(walkers)
        if len(self) == 0:
            return ExportedWalkers(0)
        return self.export_walkers()

    def import_walkers(self, walkers: ExportedWalkers):
        """
        Insert a the target :class:`ExportedWalkers` at the end of the internal \
        buffer and keep track of the best reward found.

        Args:
            walkers: Will be appended at the end of the internal buffer.

        Returns:
            None.

        """
        self._track_best_walker(walkers)
        self.buffer.append(walkers)

    def export_walkers(self) -> ExportedWalkers:
        """
        Return a :class`ExportedWalkers` sampled randomly from the internal \
        buffer.

        If ``self.add_global_best`` is ``True`` the best walker found will be \
        included in the returned :class:`ExportedWalkers`.
        """

        index = random_state.randint(0, len(self))
        walkers = self.buffer[index]
        if self.add_global_best:
            walkers = self._add_best_to_exported(walkers)
        return walkers

    def _track_best_walker(self, walkers: ExportedWalkers):
        """Update the best value found and store it inside the internal \
        :class:`BestWalker`."""
        self.best.update_best(walkers=walkers)

    def _add_best_to_exported(self, walkers: ExportedWalkers) -> ExportedWalkers:
        """Override randomly one walker of the target :class:`ExportedWalkers` \
        with the best walker found."""
        index = random_state.randint(0, len(walkers))
        walkers.rewards[index] = self.best.rewards
        walkers.id_walkers[index] = self.best.id_walkers
        walkers.observs[index] = self.best.observs
        walkers.states[index] = self.best.states
        return walkers
