#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.tagset',
  description = 'Tags and sets of tags.',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20200318',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  include_package_data = True,
  install_requires = ['cs.lex', 'cs.logutils', 'cs.pfx'],
  keywords = ['python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description = '*Latest release 20200318*:\n*Note that the TagsOntology stuff is in flux and totally alpha.*\nTag.prefix_name factory returning a new tag if prefix is not empty, ptherwise self.\nTagSet.update: accept an optional prefix for inserting "foreign" tags with a distinguishing name prefix.\nTag.as_json: turn sets and tuples into lists for encoding.\nBackport for Python < 3.7 (no fromisoformat functions).\nTagSet: drop unused and illplaced .titleify, .episode_title and .title methods.\nTagSet: remove "defaults", unused.\nMake TagSet a direct subclass of dict, adjust uses of .update etc.\nNew ExtendedNamespace class which is a SimpleNamespace with some inferred attributes and a partial mapping API (keys and __getitem__).\nNew TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles as a mapping for str.format_map; TagSet.format_kwargs is now an alias for this.\nNew Tag.from_string factory to parse a str into a Tag.\nNew TagsOntology and TypedTag classes to provide type and value-detail information; very very alpha and subject to change.\n\nTags and sets of tags.\n\n## Class `ExtendedNamespace(types.SimpleNamespace)`\n\nSubclass `SimpleNamespace` with inferred attributes.\nThis also presents attributes as `[]` elements via `__getitem__`.\n\n## Class `Tag(Tag,builtins.tuple)`\n\nA Tag has a `.name` (`str`) and a `.value`.\n\nThe `name` must be a dotted identifier.\n\nA "bare" `Tag` has a `value` of `None`.\n\n## Class `TagChoice(TagChoice,builtins.tuple)`\n\nA "tag choice", an apply/reject flag and a `Tag`,\nused to apply changes to a `TagSet`\nor as a criterion for a tag search.\n\nAttributes:\n* `spec`: the source text from which this choice was parsed,\n  possibly `None`\n* `choice`: the apply/reject flag\n* `tag`: the `Tag` representing the criterion\n\n## Class `TagSet(builtins.dict,cs.lex.FormatableMixin)`\n\nA setlike class associating a set of tag names with values.\n\n### Method `TagSet.__init__(self)`\n\nInitialise the `TagSet`.\n\n## Class `TagsOntology(cs.obj.SingletonMixin)`\n\nAn ontology for tag names.\n\nThis is based around a mapping of tag names\nto ontological information expressed as a `TagSet`.\n\nA `cs.fstags.FSTags` uses ontologies initialised from `TagFile`s\ncontaining ontology mappings.\n\n## Class `TypedTag(cs.lex.FormatableMixin)`\n\nA `Tag`like object linked to a `TagOntology`,\nproviding associated detail about a `Tag`.\n\nLike `Tag`, this has a `.name` and `.value`.\n\nAdditionally it has the following attributes:\n* `ontology`: the supporting `TagOntology`\n* `tag`: the originating `Tag`\n  (computed from the `(name,value)` tuple if supplied)\n* `defn`: the `TagSet` from `.ontology`\n  which defines this\n* `type`: `defn[\'type\']`\n* `member_type`: `defn[\'member_type\']` if present;\n  we expect `type` to be a list or mapping type name\n\nIndexing a `TypedTag` indexes its `.value`\nand returns a tuple `(element,TagSet)`\nwhere the `TagSet` is information from the ontology\nabout the element\'s value (if `element` is a `str`).\n\nIf the `.value` looks like a mapping\n.ie. it has a `.keys()` method\nthen a `TypedTag` has `.keys()` and `.items()` methods.\nThe `.keys()` call returns `.value.keys()`.\nThe `.items()` call yields `(key,self[key])`\nfor each of `self.keys()`.\n\nIterating over a `TypedTag`\nyields its keys if it has a `.keys()` method,\notherwise values from `range(len(self.value))`.\n\n### Method `TypedTag.__init__(self, name, value=None, *, ontology)`\n\nPrepare the `TypedTag` from a `Tag` or `(name,value)` tuple.\n\n\n\n# Release Log\n\n*Release 20200318*:\n*Note that the TagsOntology stuff is in flux and totally alpha.*\nTag.prefix_name factory returning a new tag if prefix is not empty, ptherwise self.\nTagSet.update: accept an optional prefix for inserting "foreign" tags with a distinguishing name prefix.\nTag.as_json: turn sets and tuples into lists for encoding.\nBackport for Python < 3.7 (no fromisoformat functions).\nTagSet: drop unused and illplaced .titleify, .episode_title and .title methods.\nTagSet: remove "defaults", unused.\nMake TagSet a direct subclass of dict, adjust uses of .update etc.\nNew ExtendedNamespace class which is a SimpleNamespace with some inferred attributes and a partial mapping API (keys and __getitem__).\nNew TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles as a mapping for str.format_map; TagSet.format_kwargs is now an alias for this.\nNew Tag.from_string factory to parse a str into a Tag.\nNew TagsOntology and TypedTag classes to provide type and value-detail information; very very alpha and subject to change.\n\n*Release 20200229.1*:\nInitial release: pull TagSet, Tag, TagChoice from cs.fstags for independent use.',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.tagset'],
)
