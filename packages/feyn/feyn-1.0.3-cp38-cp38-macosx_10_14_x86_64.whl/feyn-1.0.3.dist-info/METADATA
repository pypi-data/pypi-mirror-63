Metadata-Version: 2.1
Name: feyn
Version: 1.0.3
Summary: High level Python interface to abzu qlattice
Home-page: UNKNOWN
Author: Abzu
Author-email: support@abzu.ai
License: CC BY-ND 4.0
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Science/Research
Classifier: Intended Audience :: Developers
Classifier: Operating System :: POSIX :: Linux
Classifier: Operating System :: MacOS
Classifier: Programming Language :: C
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Software Development
Description-Content-Type: text/markdown
Requires-Dist: requests
Requires-Dist: numpy
Requires-Dist: networkx
Requires-Dist: sklearn
Requires-Dist: graphviz
Requires-Dist: matplotlib
Requires-Dist: ipython

# Feyn: AI by Abzu

Feyn is a Python library that pushes machine learning to a new level by taking strong inspiration from quantum physics. A Feyn-model is based on the [path integral formulation](https://en.wikipedia.org/wiki/Path_integral_formulation) of quantum physics originally proposed by the American physicist Richard P. Feynman.

Feyn-model is in many ways similar to Neural Network (or Deep Learning) models, so some of the concepts may be familiar to you already. But at it's core, the Feyn-model introduces a new way to work with your data together with a revolutionary way to accumulate and transfer learnings.

But let's start with the basics.

To generate a Feyn-model you need access to a Qlattice, short for Quantum Lattice. A QLattice is a high-performance quantum simulator that runs on dedicated hardware. To learn more about getting access to a QLattice, visit [www.abzu.ai](https://www.abzu.ai)

The other needed component is this Python package (feyn) that runs on your computer and accumulate learnings from your data. These learnings are communicated to your QLattice over the network.

A _QLattice_ is the heart of a Feyn-model. The QLattice is divided into 2 different parts: the _registers_ and the _interactions_.

The _registers_ are what we use to interact with the QLattice. They are the input and output interface of a Feyn-model. There are different register types, but the basics are `continuous` and `categorical`. The output register is always `continuous`. More on this later.

The _interactions_ layer is where the learnings are stored and is what we use to extract the QGraphs.

The _QGraph_ represents *all* possible graphs, from the input registers to the output register. In human words that means *all* possible explanations for the given output with the given inputs, suggested by the qlattice.

## Getting started: Feyn in 1 min

Ok, all this sounds good! But in practice how does this work?

Let us walk through a simple classification problem, step by step.

Create a blank `QLattice`.

```python
from feyn import QLattice
ql = QLattice()
ql
```

Read the example dataset and add a `register` for each column in the dataset.

```python
import sklearn.datasets
import pandas as pd

X, y = sklearn.datasets.load_breast_cancer(return_X_y=True)

in_registers = []
_data = {}

for i in range(X.shape[1]):
    label = 'inp_%i' % i
    _data[label] = X[:, i]
    in_registers.append(ql.add_register(label=label, register_type="cont"))

X = pd.DataFrame(_data)
out_reg = ql.add_register(label='out')
```

Now the `QLattice` is prepared for your problem.

Next, run for some epochs, where you retrieve a new `QGraph`, tune it, and update the `QLattice` with the learnings from the best graph.

The update calls will bias the `QLattice` from your learnings. Meaning that next time you call `QLattice.get_qgraph`, the `QGraph` will fit your problem better.

```python
from sklearn.model_selection import train_test_split

X_test, X_train, y_test, y_train = train_test_split(X, y, test_size=0.33)

for _ in range(10):
    qgraph = ql.get_qgraph(in_registers, out_reg)
    qgraph.tune(X_train, y_train, epochs=10)
    best_graph = qgraph.graphs[0]
    ql.update(best_graph)
```

Finally, evaluate the results in the test dataset.

```python
from feyn import tools

prediction = best_graph.predict(X_test)
tools.plot_confusion_matrix(y_true=y_test,
                                y_pred=prediction.round(),
                                title="Evaluation Results")
```

For a detailed tutorial about Feyn continue with:

* Getting Started with Feyn
* Building complex trainers

### Installation

Feyn is available as python package distributed from PyPi server.

Requirements:

* OS: Linux
* Python 3.6, 3.7 or 3.8
* Graphviz is used to draw charts (optional):

```bash
foo@bar:~$ sudo apt install graphviz
```

You can install it with the following command

```bash
foo@bar:~$ pip3 install feyn
```

Alternatively or if you don't have Linux OS you can use the jupyterlab Docker image.

```bash
foo@bar:~$ docker run -it --net=host abzu/jupyterlab:latest
```

adding the current folder as /data to the working directory.

```bash
foo@bar:~$ docker run -it --net=host -v $(pwd):/data abzu/jupyterlab:latest
```


