#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class PDDLBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=';.*$',
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(PDDLBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class PDDLParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=';.*$',
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=PDDLBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(PDDLParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _start_(self):  # noqa
        self._pddl_doc_()

    @tatsumasu()
    def _pddl_doc_(self):  # noqa
        with self._choice():
            with self._option():
                self._domain_()
            with self._option():
                self._problem_()
            self._error('no available options')

    @tatsumasu('DomainNode')
    def _domain_(self):  # noqa
        self._token('(')
        self._token('define')
        self._domain_name_()
        self.name_last_node('domain')
        with self._optional():
            self._require_def_()
            self.name_last_node('requirements')
        with self._optional():
            self._types_def_()
            self.name_last_node('types')
        with self._optional():
            self._constants_def_()
            self.name_last_node('constants')
        with self._optional():
            self._predicates_def_()
            self.name_last_node('predicates')
        with self._optional():
            self._functions_def_()
        with self._optional():
            self._constraints_()

        def block6():
            self._structure_def_()
        self._closure(block6)
        self.name_last_node('structures')
        self._token(')')
        self.ast._define(
            ['constants', 'domain', 'predicates', 'requirements', 'structures', 'types'],
            []
        )

    @tatsumasu()
    def _domain_name_(self):  # noqa
        self._token('(')
        self._token('domain')
        self._name_()
        self.name_last_node('name')
        self._token(')')
        self.ast._define(
            ['name'],
            []
        )

    @tatsumasu()
    def _require_def_(self):  # noqa
        self._token('(')
        self._token(':requirements')

        def block0():
            self._require_key_()
        self._positive_closure(block0)
        self._token(')')

    @tatsumasu('TypesNode')
    def _types_def_(self):  # noqa
        self._token('(')
        self._token(':types')
        self._typed_name_list_()
        self.name_last_node('types')
        self._token(')')
        self.ast._define(
            ['types'],
            []
        )

    @tatsumasu()
    def _typed_name_list_(self):  # noqa
        with self._group():

            def block0():
                self._single_type_name_list_()
            self._closure(block0)

    @tatsumasu('TypeNode')
    def _single_type_name_list_(self):  # noqa
        with self._group():

            def block1():
                self._name_()
            self._positive_closure(block1)
            self.name_last_node('subtypes')
            with self._optional():
                self._token('-')
                self._r_type_()
                self.name_last_node('supertype')
        self.ast._define(
            ['subtypes', 'supertype'],
            []
        )

    @tatsumasu()
    def _r_type_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('either')

                    def block0():
                        self._prim_type_()
                    self._positive_closure(block0)
                    self._token(')')
            with self._option():
                self._prim_type_()
            self._error('no available options')

    @tatsumasu()
    def _prim_type_(self):  # noqa
        self._name_()

    @tatsumasu()
    def _functions_def_(self):  # noqa
        self._token('(')
        self._token(':functions')
        self._function_list_()
        self._token(')')

    @tatsumasu()
    def _function_list_(self):  # noqa

        def block0():

            def block1():
                self._atomic_function_skeleton_()
            self._positive_closure(block1)
            with self._optional():
                self._token('-')
                self._function_type_()
        self._closure(block0)

    @tatsumasu()
    def _atomic_function_skeleton_(self):  # noqa
        self._token('(')
        self._function_symbol_()
        self._typed_variable_list_()
        self._token(')')

    @tatsumasu()
    def _function_symbol_(self):  # noqa
        self._name_()

    @tatsumasu()
    def _function_type_(self):  # noqa
        self._token('number')

    @tatsumasu()
    def _constants_def_(self):  # noqa
        self._token('(')
        self._token(':constants')
        self._typed_name_list_()
        self._token(')')

    @tatsumasu('PredicatesNode')
    def _predicates_def_(self):  # noqa
        self._token('(')
        self._token(':predicates')

        def block1():
            self._atomic_formula_skeleton_()
        self._positive_closure(block1)
        self.name_last_node('predicates')
        self._token(')')
        self.ast._define(
            ['predicates'],
            []
        )

    @tatsumasu('PredicateNode')
    def _atomic_formula_skeleton_(self):  # noqa
        self._token('(')
        self._predicate_()
        self.name_last_node('name')

        def block2():
            self._typed_variable_list_()
        self._positive_closure(block2)
        self.name_last_node('parameters')
        self._token(')')
        self.ast._define(
            ['name', 'parameters'],
            []
        )

    @tatsumasu()
    def _predicate_(self):  # noqa
        self._name_()

    @tatsumasu('ParameterNode')
    def _typed_variable_list_(self):  # noqa
        with self._group():

            def block1():
                self._VARIABLE_()
            self._positive_closure(block1)
            self.name_last_node('names')
            with self._optional():
                self._token('-')
                self._r_type_()
                self.name_last_node('type')
        self.ast._define(
            ['names', 'type'],
            []
        )

    @tatsumasu()
    def _single_type_var_list_(self):  # noqa
        with self._group():

            def block0():
                self._VARIABLE_()
            self._positive_closure(block0)
            self._token('-')
            self._r_type_()
            self.name_last_node('t')
        self.ast._define(
            ['t'],
            []
        )

    @tatsumasu()
    def _constraints_(self):  # noqa
        self._token('(')
        self._token(':constraints')
        self._con_gD_()
        self._token(')')

    @tatsumasu()
    def _structure_def_(self):  # noqa
        with self._choice():
            with self._option():
                self._action_def_()
            with self._option():
                self._durative_action_def_()
            with self._option():
                self._derived_def_()
            self._error('no available options')

    @tatsumasu('RuleNode')
    def _action_def_(self):  # noqa
        self._token('(')
        self._token(':action')
        self._action_symbol_()
        self.name_last_node('name')
        self._token(':parameters')
        self._token('(')

        def block2():
            self._typed_variable_list_()
        self._positive_closure(block2)
        self.name_last_node('parameters')
        self._token(')')
        self._action_def_body_()
        self.name_last_node('body')
        self._token(')')
        self.ast._define(
            ['body', 'name', 'parameters'],
            []
        )

    @tatsumasu()
    def _action_symbol_(self):  # noqa
        self._name_()

    @tatsumasu()
    def _action_def_body_(self):  # noqa
        with self._optional():
            self._token(':precondition')
            with self._group():
                with self._choice():
                    with self._option():
                        with self._group():
                            self._token('(')
                            self._token(')')
                    with self._option():
                        self._precondition_()
                    self._error('no available options')
        self.name_last_node('precondition')
        with self._optional():
            self._token(':effect')
            with self._group():
                with self._choice():
                    with self._option():
                        with self._group():
                            self._token('(')
                            self._token(')')
                    with self._option():
                        self._effect_()
                    self._error('no available options')
        self.name_last_node('effect')
        self.ast._define(
            ['effect', 'precondition'],
            []
        )

    @tatsumasu()
    def _precondition_(self):  # noqa
        self._goal_desc_()

    @tatsumasu('GoalNode')
    def _goal_desc_(self):  # noqa
        with self._choice():
            with self._option():
                self._atomic_term_formula_()
                self.name_last_node('atomic')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('and')

                    def block2():
                        self._goal_desc_()
                    self._closure(block2)
                    self._token(')')
                self.name_last_node('and_')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('or')

                    def block4():
                        self._goal_desc_()
                    self._closure(block4)
                    self._token(')')
                self.name_last_node('or_')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('not')
                    self._goal_desc_()
                    self._token(')')
                self.name_last_node('not_')
            with self._option():
                self._token('(')
                self._token('imply')
                self._goal_desc_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('exists')
                    self._token('(')

                    def block8():
                        self._typed_variable_list_()
                    self._closure(block8)
                    self.name_last_node('parameters')
                    self._token(')')
                    self._goal_desc_()
                    self.name_last_node('predicates')
                    self._token(')')
                self.name_last_node('exists')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('forall')
                    self._token('(')

                    def block12():
                        self._typed_variable_list_()
                    self._closure(block12)
                    self.name_last_node('parameters')
                    self._token(')')
                    self._goal_desc_()
                    self.name_last_node('predicates')
                    self._token(')')
                self.name_last_node('forall')
            with self._option():
                self._f_comp_()
            self._error('no available options')
        self.ast._define(
            ['and_', 'atomic', 'exists', 'forall', 'not_', 'or_', 'parameters', 'predicates'],
            []
        )

    @tatsumasu()
    def _f_comp_(self):  # noqa
        self._token('(')
        self._binary_comp_()
        self._f_exp_()
        self._f_exp_()
        self._token(')')

    @tatsumasu('Predicate2Node')
    def _atomic_term_formula_(self):  # noqa
        self._token('(')
        self._predicate_()
        self.name_last_node('name')

        def block2():
            self._term_()
        self._closure(block2)
        self.name_last_node('parameters')
        self._token(')')
        self.ast._define(
            ['name', 'parameters'],
            []
        )

    @tatsumasu()
    def _term_(self):  # noqa
        with self._choice():
            with self._option():
                self._name_()
            with self._option():
                self._VARIABLE_()
            self._error('no available options')

    @tatsumasu()
    def _durative_action_def_(self):  # noqa
        self._token('(')
        self._token(':durative-action')
        self._action_symbol_()
        self._token(':parameters')
        self._token('(')

        def block0():
            self._typed_variable_list_()
        self._closure(block0)
        self._token(')')
        self._da_def_body_()
        self._token(')')

    @tatsumasu()
    def _da_def_body_(self):  # noqa
        self._token(':duration')
        self._duration_constraint_()
        self._token(':condition')
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('(')
                        self._token(')')
                with self._option():
                    self._da_gD_()
                self._error('no available options')
        self._token(':effect')
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('(')
                        self._token(')')
                with self._option():
                    self._da_effect_()
                self._error('no available options')

    @tatsumasu()
    def _da_gD_(self):  # noqa
        with self._choice():
            with self._option():
                self._pref_timed_gD_()
            with self._option():
                self._token('(')
                self._token('and')

                def block0():
                    self._da_gD_()
                self._closure(block0)
                self._token(')')
            with self._option():
                self._token('(')
                self._token('forall')
                self._token('(')

                def block1():
                    self._typed_variable_list_()
                self._closure(block1)
                self._token(')')
                self._da_gD_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _pref_timed_gD_(self):  # noqa
        with self._choice():
            with self._option():
                self._timed_gD_()
            with self._option():
                self._token('(')
                self._token('preference')
                with self._optional():
                    self._name_()
                self._timed_gD_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _timed_gD_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('at')
                self._time_specifier_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('over')
                self._interval_()
                self._goal_desc_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _time_specifier_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('start')
            with self._option():
                self._token('end')
            self._error('no available options')

    @tatsumasu()
    def _interval_(self):  # noqa
        self._token('all')

    @tatsumasu('AliasNode')
    def _derived_def_(self):  # noqa
        self._token('(')
        self._token(':derived')
        self._atomic_formula_skeleton_()
        self.name_last_node('alias')
        self._goal_desc_()
        self.name_last_node('replacement')
        self._token(')')
        self.ast._define(
            ['alias', 'replacement'],
            []
        )

    @tatsumasu()
    def _f_exp_(self):  # noqa
        with self._choice():
            with self._option():
                self._NUMBER_()
            with self._option():
                self._token('(')
                self._binary_op_()
                self._f_exp_()
                self._f_exp2_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('-')
                self._f_exp_()
                self._token(')')
            with self._option():
                self._f_head_()
            self._error('no available options')

    @tatsumasu()
    def _f_exp2_(self):  # noqa
        self._f_exp_()

    @tatsumasu()
    def _f_head_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._function_symbol_()

                def block0():
                    self._term_()
                self._closure(block0)
                self._token(')')
            with self._option():
                self._function_symbol_()
            self._error('no available options')

    @tatsumasu('EffectNode')
    def _effect_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('and')

                    def block1():
                        self._c_effect_()
                    self._closure(block1)
                    self._token(')')
                self.name_last_node('and_')
            with self._option():
                self._c_effect_()
                self.name_last_node('atomic')
            self._error('no available options')
        self.ast._define(
            ['and_', 'atomic'],
            []
        )

    @tatsumasu('EffectNode')
    def _c_effect_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('forall')
                    self._token('(')

                    def block2():
                        self._typed_variable_list_()
                    self._closure(block2)
                    self.name_last_node('parameters')
                    self._token(')')
                    self._effect_()
                    self.name_last_node('predicates')
                    self._token(')')
                self.name_last_node('forall')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('when')
                    self._goal_desc_()
                    self._cond_effect_()
                    self._token(')')
                self.name_last_node('when')
            with self._option():
                self._p_effect_()
                self.name_last_node('atomic')
            self._error('no available options')
        self.ast._define(
            ['atomic', 'forall', 'parameters', 'predicates', 'when'],
            []
        )

    @tatsumasu('EffectNode')
    def _p_effect_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._assign_op_()
                self._f_head_()
                self._f_exp_()
                self._token(')')
            with self._option():
                with self._group():
                    self._token('(')
                    self._token('not')
                    self._atomic_term_formula_()
                    self._token(')')
                self.name_last_node('not_')
            with self._option():
                self._atomic_term_formula_()
                self.name_last_node('atomic')
            self._error('no available options')
        self.ast._define(
            ['atomic', 'not_'],
            []
        )

    @tatsumasu()
    def _cond_effect_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('and')

                def block0():
                    self._p_effect_()
                self._closure(block0)
                self._token(')')
            with self._option():
                self._p_effect_()
            self._error('no available options')

    @tatsumasu()
    def _binary_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('*')
            with self._option():
                self._token('+')
            with self._option():
                self._token('-')
            with self._option():
                self._token('/')
            self._error('no available options')

    @tatsumasu()
    def _binary_comp_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('>')
            with self._option():
                self._token('<')
            with self._option():
                self._token('=')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('<=')
            self._error('no available options')

    @tatsumasu()
    def _assign_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('assign')
            with self._option():
                self._token('scale-up')
            with self._option():
                self._token('scale-down')
            with self._option():
                self._token('increase')
            with self._option():
                self._token('decrease')
            self._error('no available options')

    @tatsumasu()
    def _duration_constraint_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('and')

                def block0():
                    self._simple_duration_constraint_()
                self._positive_closure(block0)
                self._token(')')
            with self._option():
                self._token('(')
                self._token(')')
            with self._option():
                self._simple_duration_constraint_()
            self._error('no available options')

    @tatsumasu()
    def _simple_duration_constraint_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._dur_op_()
                self._token('?duration')
                self._dur_value_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('at')
                self._time_specifier_()
                self._simple_duration_constraint_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _dur_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('<=')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('=')
            self._error('no available options')

    @tatsumasu()
    def _dur_value_(self):  # noqa
        with self._choice():
            with self._option():
                self._NUMBER_()
            with self._option():
                self._f_exp_()
            self._error('no available options')

    @tatsumasu()
    def _da_effect_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('and')

                def block0():
                    self._da_effect_()
                self._closure(block0)
                self._token(')')
            with self._option():
                self._timed_effect_()
            with self._option():
                self._token('(')
                self._token('forall')
                self._token('(')

                def block1():
                    self._typed_variable_list_()
                self._closure(block1)
                self._token(')')
                self._da_effect_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('when')
                self._da_gD_()
                self._timed_effect_()
                self._token(')')
            with self._option():
                self._token('(')
                self._assign_op_()
                self._f_head_()
                self._f_exp_dA_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _timed_effect_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('at')
                self._time_specifier_()
                self._c_effect_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('at')
                self._time_specifier_()
                self._f_assign_dA_()
                self._token(')')
            with self._option():
                self._token('(')
                self._assign_op_t_()
                self._f_head_()
                self._f_exp_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _f_assign_dA_(self):  # noqa
        self._token('(')
        self._assign_op_()
        self._f_head_()
        self._f_exp_dA_()
        self._token(')')

    @tatsumasu()
    def _f_exp_dA_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                self._binary_op_()
                                self._f_exp_dA_()
                                self._f_exp_dA_()
                        with self._option():
                            with self._group():
                                self._token('-')
                                self._f_exp_dA_()
                        self._error('no available options')
                self._token(')')
            with self._option():
                self._token('?duration')
            with self._option():
                self._f_exp_()
            self._error('no available options')

    @tatsumasu()
    def _assign_op_t_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('increase')
            with self._option():
                self._token('decrease')
            self._error('no available options')

    @tatsumasu()
    def _problem_(self):  # noqa
        self._token('(')
        self._token('define')
        self._problem_decl_()
        self._problem_domain_()
        with self._optional():
            self._require_def_()
        with self._optional():
            self._object_decl_()
        self._init_()
        self._goal_()
        with self._optional():
            self._prob_constraints_()
        with self._optional():
            self._metric_spec_()
        self._token(')')

    @tatsumasu()
    def _problem_decl_(self):  # noqa
        self._token('(')
        self._token('problem')
        self._name_()
        self._token(')')

    @tatsumasu()
    def _problem_domain_(self):  # noqa
        self._token('(')
        self._token(':domain')
        self._name_()
        self._token(')')

    @tatsumasu()
    def _object_decl_(self):  # noqa
        self._token('(')
        self._token(':objects')
        self._typed_name_list_()
        self._token(')')

    @tatsumasu()
    def _init_(self):  # noqa
        self._token('(')
        self._token(':init')

        def block0():
            self._init_el_()
        self._closure(block0)
        self._token(')')

    @tatsumasu()
    def _init_el_(self):  # noqa
        with self._choice():
            with self._option():
                self._name_literal_()
            with self._option():
                self._token('(')
                self._token('=')
                self._f_head_()
                self._NUMBER_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('at')
                self._NUMBER_()
                self._name_literal_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _name_literal_(self):  # noqa
        with self._choice():
            with self._option():
                self._atomic_name_formula_()
            with self._option():
                self._token('(')
                self._token('not')
                self._atomic_name_formula_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _atomic_name_formula_(self):  # noqa
        self._token('(')
        self._predicate_()

        def block0():
            self._name_()
        self._closure(block0)
        self._token(')')

    @tatsumasu()
    def _goal_(self):  # noqa
        self._token('(')
        self._token(':goal')
        self._goal_desc_()
        self._token(')')

    @tatsumasu()
    def _prob_constraints_(self):  # noqa
        self._token('(')
        self._token(':constraints')
        self._pref_con_gD_()
        self._token(')')

    @tatsumasu()
    def _pref_con_gD_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('and')

                def block0():
                    self._pref_con_gD_()
                self._closure(block0)
                self._token(')')
            with self._option():
                self._token('(')
                self._token('forall')
                self._token('(')

                def block1():
                    self._typed_variable_list_()
                self._closure(block1)
                self._token(')')
                self._pref_con_gD_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('preference')
                with self._optional():
                    self._name_()
                self._con_gD_()
                self._token(')')
            with self._option():
                self._con_gD_()
            self._error('no available options')

    @tatsumasu()
    def _metric_spec_(self):  # noqa
        self._token('(')
        self._token(':metric')
        self._optimization_()
        self._metric_fExp_()
        self._token(')')

    @tatsumasu()
    def _optimization_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('minimize')
            with self._option():
                self._token('maximize')
            self._error('no available options')

    @tatsumasu()
    def _metric_fExp_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._binary_op_()
                self._metric_fExp_()
                self._metric_fExp_()
                self._token(')')
            with self._option():
                self._token('(')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('*')
                        with self._option():
                            self._token('/')
                        self._error('no available options')
                self._metric_fExp_()

                def block1():
                    self._metric_fExp_()
                self._positive_closure(block1)
                self._token(')')
            with self._option():
                self._token('(')
                self._token('-')
                self._metric_fExp_()
                self._token(')')
            with self._option():
                self._NUMBER_()
            with self._option():
                self._token('(')
                self._function_symbol_()

                def block2():
                    self._name_()
                self._closure(block2)
                self._token(')')
            with self._option():
                self._function_symbol_()
            with self._option():
                self._token('total-time')
            with self._option():
                self._token('(')
                self._token('is-violated')
                self._name_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _con_gD_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._token('and')

                def block0():
                    self._con_gD_()
                self._closure(block0)
                self._token(')')
            with self._option():
                self._token('(')
                self._token('forall')
                self._token('(')

                def block1():
                    self._typed_variable_list_()
                self._closure(block1)
                self._token(')')
                self._con_gD_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('at')
                self._token('end')
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('always')
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('sometime')
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('within')
                self._NUMBER_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('at-most-once')
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('sometime-after')
                self._goal_desc_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('sometime-before')
                self._goal_desc_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('always-within')
                self._NUMBER_()
                self._goal_desc_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('hold-during')
                self._NUMBER_()
                self._NUMBER_()
                self._goal_desc_()
                self._token(')')
            with self._option():
                self._token('(')
                self._token('hold-after')
                self._NUMBER_()
                self._goal_desc_()
                self._token(')')
            self._error('no available options')

    @tatsumasu()
    def _require_key_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(':strips')
            with self._option():
                self._token(':typing')
            with self._option():
                self._token(':negative-preconditions')
            with self._option():
                self._token(':disjunctive-preconditions')
            with self._option():
                self._token(':equality')
            with self._option():
                self._token(':existential-preconditions')
            with self._option():
                self._token(':universal-preconditions')
            with self._option():
                self._token(':quantified-preconditions')
            with self._option():
                self._token(':conditional-effects')
            with self._option():
                self._token(':fluents')
            with self._option():
                self._token(':adl')
            with self._option():
                self._token(':durative-actions')
            with self._option():
                self._token(':derived-predicates')
            with self._option():
                self._token(':timed-initial-literals')
            with self._option():
                self._token(':preferences')
            with self._option():
                self._token(':constraints')
            self._error('no available options')

    @tatsumasu('NameNode')
    def _name_(self):  # noqa
        with self._choice():
            with self._option():
                self._NAME_()
            with self._option():
                self._token('at')
            with self._option():
                self._token('over')
            self._error('no available options')

    @tatsumasu()
    def _NAME_(self):  # noqa
        self._LETTER_()

        def block0():
            self._ANY_CHAR_()
        self._closure(block0)

    @tatsumasu()
    def _LETTER_(self):  # noqa
        self._pattern('[a-zA-Z]')

    @tatsumasu()
    def _ANY_CHAR_(self):  # noqa
        with self._choice():
            with self._option():
                self._LETTER_()
            with self._option():
                self._pattern('[0-9-_]')
            self._error('no available options')

    @tatsumasu('VariableNode')
    def _VARIABLE_(self):  # noqa
        self._token('?')
        self._LETTER_()
        self.name_last_node('first')

        def block2():
            self._ANY_CHAR_()
        self._closure(block2)
        self.name_last_node('rest')
        self.ast._define(
            ['first', 'rest'],
            []
        )

    @tatsumasu()
    def _NUMBER_(self):  # noqa

        def block0():
            self._DIGIT_()
        self._positive_closure(block0)
        with self._optional():
            self._token('.')

            def block1():
                self._DIGIT_()
            self._positive_closure(block1)

    @tatsumasu()
    def _DIGIT_(self):  # noqa
        self._pattern('[0-9]')

    @tatsumasu()
    def _LINE_COMMENT_(self):  # noqa
        self._token(';')
        with self._ifnot():
            self._pattern('[\\n\\r]*')
        self._pattern('.')
        with self._optional():
            self._token('\\r')
        self._token('\\n')

    @tatsumasu()
    def _whitespace_(self):  # noqa
        self._pattern('[ \\t\\r\\n]+')

    @tatsumasu()
    def _DOMAIN_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _DOMAIN_NAME_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _REQUIREMENTS_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _TYPES_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _EITHER_TYPE_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _CONSTANTS_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _FUNCTIONS_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PREDICATES_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _ACTION_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _DURATIVE_ACTION_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PROBLEM_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PROBLEM_NAME_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PROBLEM_DOMAIN_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _OBJECTS_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _INIT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _FUNC_HEAD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PRECONDITION_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _EFFECT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _AND_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _OR_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _NOT_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _IMPLY_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _EXISTS_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _FORALL_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _COMPARISON_GD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _AND_EFFECT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _FORALL_EFFECT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _WHEN_EFFECT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _ASSIGN_EFFECT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _NOT_EFFECT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PRED_HEAD_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _GOAL_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _BINARY_OP_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _UNARY_MINUS_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _INIT_EQ_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _INIT_AT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _NOT_PRED_INIT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PRED_INST_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PROBLEM_CONSTRAINT_(self):  # noqa
        with self._ifnot():
            self._void()

    @tatsumasu()
    def _PROBLEM_METRIC_(self):  # noqa
        with self._ifnot():
            self._void()


class PDDLSemantics(object):
    def start(self, ast):  # noqa
        return ast

    def pddl_doc(self, ast):  # noqa
        return ast

    def domain(self, ast):  # noqa
        return ast

    def domain_name(self, ast):  # noqa
        return ast

    def require_def(self, ast):  # noqa
        return ast

    def types_def(self, ast):  # noqa
        return ast

    def typed_name_list(self, ast):  # noqa
        return ast

    def single_type_name_list(self, ast):  # noqa
        return ast

    def r_type(self, ast):  # noqa
        return ast

    def prim_type(self, ast):  # noqa
        return ast

    def functions_def(self, ast):  # noqa
        return ast

    def function_list(self, ast):  # noqa
        return ast

    def atomic_function_skeleton(self, ast):  # noqa
        return ast

    def function_symbol(self, ast):  # noqa
        return ast

    def function_type(self, ast):  # noqa
        return ast

    def constants_def(self, ast):  # noqa
        return ast

    def predicates_def(self, ast):  # noqa
        return ast

    def atomic_formula_skeleton(self, ast):  # noqa
        return ast

    def predicate(self, ast):  # noqa
        return ast

    def typed_variable_list(self, ast):  # noqa
        return ast

    def single_type_var_list(self, ast):  # noqa
        return ast

    def constraints(self, ast):  # noqa
        return ast

    def structure_def(self, ast):  # noqa
        return ast

    def action_def(self, ast):  # noqa
        return ast

    def action_symbol(self, ast):  # noqa
        return ast

    def action_def_body(self, ast):  # noqa
        return ast

    def precondition(self, ast):  # noqa
        return ast

    def goal_desc(self, ast):  # noqa
        return ast

    def f_comp(self, ast):  # noqa
        return ast

    def atomic_term_formula(self, ast):  # noqa
        return ast

    def term(self, ast):  # noqa
        return ast

    def durative_action_def(self, ast):  # noqa
        return ast

    def da_def_body(self, ast):  # noqa
        return ast

    def da_gD(self, ast):  # noqa
        return ast

    def pref_timed_gD(self, ast):  # noqa
        return ast

    def timed_gD(self, ast):  # noqa
        return ast

    def time_specifier(self, ast):  # noqa
        return ast

    def interval(self, ast):  # noqa
        return ast

    def derived_def(self, ast):  # noqa
        return ast

    def f_exp(self, ast):  # noqa
        return ast

    def f_exp2(self, ast):  # noqa
        return ast

    def f_head(self, ast):  # noqa
        return ast

    def effect(self, ast):  # noqa
        return ast

    def c_effect(self, ast):  # noqa
        return ast

    def p_effect(self, ast):  # noqa
        return ast

    def cond_effect(self, ast):  # noqa
        return ast

    def binary_op(self, ast):  # noqa
        return ast

    def binary_comp(self, ast):  # noqa
        return ast

    def assign_op(self, ast):  # noqa
        return ast

    def duration_constraint(self, ast):  # noqa
        return ast

    def simple_duration_constraint(self, ast):  # noqa
        return ast

    def dur_op(self, ast):  # noqa
        return ast

    def dur_value(self, ast):  # noqa
        return ast

    def da_effect(self, ast):  # noqa
        return ast

    def timed_effect(self, ast):  # noqa
        return ast

    def f_assign_dA(self, ast):  # noqa
        return ast

    def f_exp_dA(self, ast):  # noqa
        return ast

    def assign_op_t(self, ast):  # noqa
        return ast

    def problem(self, ast):  # noqa
        return ast

    def problem_decl(self, ast):  # noqa
        return ast

    def problem_domain(self, ast):  # noqa
        return ast

    def object_decl(self, ast):  # noqa
        return ast

    def init(self, ast):  # noqa
        return ast

    def init_el(self, ast):  # noqa
        return ast

    def name_literal(self, ast):  # noqa
        return ast

    def atomic_name_formula(self, ast):  # noqa
        return ast

    def goal(self, ast):  # noqa
        return ast

    def prob_constraints(self, ast):  # noqa
        return ast

    def pref_con_gD(self, ast):  # noqa
        return ast

    def metric_spec(self, ast):  # noqa
        return ast

    def optimization(self, ast):  # noqa
        return ast

    def metric_fExp(self, ast):  # noqa
        return ast

    def con_gD(self, ast):  # noqa
        return ast

    def require_key(self, ast):  # noqa
        return ast

    def name(self, ast):  # noqa
        return ast

    def NAME(self, ast):  # noqa
        return ast

    def LETTER(self, ast):  # noqa
        return ast

    def ANY_CHAR(self, ast):  # noqa
        return ast

    def VARIABLE(self, ast):  # noqa
        return ast

    def NUMBER(self, ast):  # noqa
        return ast

    def DIGIT(self, ast):  # noqa
        return ast

    def LINE_COMMENT(self, ast):  # noqa
        return ast

    def whitespace(self, ast):  # noqa
        return ast

    def DOMAIN(self, ast):  # noqa
        return ast

    def DOMAIN_NAME(self, ast):  # noqa
        return ast

    def REQUIREMENTS(self, ast):  # noqa
        return ast

    def TYPES(self, ast):  # noqa
        return ast

    def EITHER_TYPE(self, ast):  # noqa
        return ast

    def CONSTANTS(self, ast):  # noqa
        return ast

    def FUNCTIONS(self, ast):  # noqa
        return ast

    def PREDICATES(self, ast):  # noqa
        return ast

    def ACTION(self, ast):  # noqa
        return ast

    def DURATIVE_ACTION(self, ast):  # noqa
        return ast

    def PROBLEM(self, ast):  # noqa
        return ast

    def PROBLEM_NAME(self, ast):  # noqa
        return ast

    def PROBLEM_DOMAIN(self, ast):  # noqa
        return ast

    def OBJECTS(self, ast):  # noqa
        return ast

    def INIT(self, ast):  # noqa
        return ast

    def FUNC_HEAD(self, ast):  # noqa
        return ast

    def PRECONDITION(self, ast):  # noqa
        return ast

    def EFFECT(self, ast):  # noqa
        return ast

    def AND_GD(self, ast):  # noqa
        return ast

    def OR_GD(self, ast):  # noqa
        return ast

    def NOT_GD(self, ast):  # noqa
        return ast

    def IMPLY_GD(self, ast):  # noqa
        return ast

    def EXISTS_GD(self, ast):  # noqa
        return ast

    def FORALL_GD(self, ast):  # noqa
        return ast

    def COMPARISON_GD(self, ast):  # noqa
        return ast

    def AND_EFFECT(self, ast):  # noqa
        return ast

    def FORALL_EFFECT(self, ast):  # noqa
        return ast

    def WHEN_EFFECT(self, ast):  # noqa
        return ast

    def ASSIGN_EFFECT(self, ast):  # noqa
        return ast

    def NOT_EFFECT(self, ast):  # noqa
        return ast

    def PRED_HEAD(self, ast):  # noqa
        return ast

    def GOAL(self, ast):  # noqa
        return ast

    def BINARY_OP(self, ast):  # noqa
        return ast

    def UNARY_MINUS(self, ast):  # noqa
        return ast

    def INIT_EQ(self, ast):  # noqa
        return ast

    def INIT_AT(self, ast):  # noqa
        return ast

    def NOT_PRED_INIT(self, ast):  # noqa
        return ast

    def PRED_INST(self, ast):  # noqa
        return ast

    def PROBLEM_CONSTRAINT(self, ast):  # noqa
        return ast

    def PROBLEM_METRIC(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'start'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = PDDLParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, PDDLParser, name='PDDL')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
